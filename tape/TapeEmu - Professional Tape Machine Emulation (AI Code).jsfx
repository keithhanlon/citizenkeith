desc: TapeEmu - Professional Tape Machine Emulation
version: 2.0a
author: citizenkeith - Claude AI
about: Tape emulation that includes tape machine choices
// Linux users can download the Trebuchet MS font at https://font.download/font/trebuchet-ms-2

// @version 2.0a
// @author citizenkeith
// @license GPL v3
// @depends ../citizenkeith-ui-lib/citizenkeith-ui-lib.jsfx
// @changelog
//   v2.0a
//     Complete GUI overhaul with machine selector buttons
//     Added double-click to reset knobs to default values
//     Fixed head bump implementation (low shelf @ 90Hz)
//     Fixed Ampex ATR102 gain staging (was 1.7dB hot)
//     Added machine-specific high-frequency rolloff
//     Unity gain by default (0% input, 0dB output)
//     Conditional dimming of Noise and Head Bump knobs when presets active
//     Input/Output LED meters
//     5 tape machine models: Studer A800, Ampex ATR102, Sony APR5000, Otari MTR90, Basic Tape

options: no_meter

// Import UI library
import citizenkeith-ui-lib.jsfx-inc

slider1:0<0,178,1>-Input/Saturation (%)
slider2:0<-50,0,1>-Output (dB)
slider3:-105<-105,-60,1>-Noise (dB)
slider4:0<0,18,0.1>-Head Bump (dB)
slider5:0<0,100,1>-Tape Age (%)
slider6:100<0,200,1>-Stereo Width (%)
slider7:4<0,4,1{Studer A800,Ampex ATR102,Sony APR5000,Otari MTR90,Basic Tape}>-Tape Machine
slider8:0<0,100,1>-Wow & Flutter (%)

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

@init
// Tape age and wow/flutter variables
age_dropout_counter = 0;
dropout_counter = 0;
age_noise_seed = 12345;

// Wow and flutter variables
wow_phase = 0;
flutter_phase = 0;
wf_buffer_l = 0;
wf_buffer_r = 1024;
wf_write_pos = 0;
wf_buffer_size = 1024;

// Head bump filter variables
hb_b0 = hb_b1 = hb_b2 = 0;
hb_a1 = hb_a2 = 0;
hb_x1_l = hb_x2_l = hb_y1_l = hb_y2_l = 0;
hb_x1_r = hb_x2_r = hb_y1_r = hb_y2_r = 0;

// High-frequency rolloff filter variables
hf_b0 = hf_b1 = hf_b2 = 0;
hf_a1 = hf_a2 = 0;
hf_x1_l = hf_x2_l = hf_y1_l = hf_y2_l = 0;
hf_x1_r = hf_x2_r = hf_y1_r = hf_y2_r = 0;

// Tape machine preset variables
preset_head_bump = 0;
preset_sat_character = 1.0;
preset_noise_floor = -105;
preset_output_compensation = 1.0;
preset_hf_rolloff_freq = 20000;
preset_hf_rolloff_amount = 0;

// UI setup
ext_noinit = 1;
freemem = ui_setup(0);

// Peak meters
input_peak_l = input_peak_r = 0;
output_peak_l = output_peak_r = 0;
meter_decay = exp(-1/(0.3*srate)); // 300ms decay

// Function to load tape machine presets
function load_tape_preset(preset_num) (
  preset_num == 0 ? ( // Studer A800
    preset_head_bump = 6;
    preset_sat_character = 0.8;
    preset_noise_floor = -95;
    preset_output_compensation = 1.0;
    preset_hf_rolloff_freq = 15000;
    preset_hf_rolloff_amount = -3;
  ) : preset_num == 1 ? ( // Ampex ATR102
    preset_head_bump = 8;
    preset_sat_character = 1.2;
    preset_noise_floor = -90;
    preset_output_compensation = 0.823;
    preset_hf_rolloff_freq = 12000;
    preset_hf_rolloff_amount = -4;
  ) : preset_num == 2 ? ( // Sony APR5000
    preset_head_bump = 4;
    preset_sat_character = 0.6;
    preset_noise_floor = -98;
    preset_output_compensation = 1.0;
    preset_hf_rolloff_freq = 18000;
    preset_hf_rolloff_amount = -1.5;
  ) : preset_num == 3 ? ( // Otari MTR90
    preset_head_bump = 5;
    preset_sat_character = 0.9;
    preset_noise_floor = -96;
    preset_output_compensation = 1.0;
    preset_hf_rolloff_freq = 14000;
    preset_hf_rolloff_amount = -2.5;
  ) : ( // Basic Tape
    preset_head_bump = slider4;
    preset_sat_character = 1.0;
    preset_noise_floor = slider3;
    preset_output_compensation = 1.0;
    preset_hf_rolloff_freq = 20000;
    preset_hf_rolloff_amount = 0;
  );
);

function calculate_head_bump_filter() local(A, w0, cosw0, sinw0, alpha, beta, a0) (
  head_bump_db = (slider7 == 4 ? slider4 : preset_head_bump);
  
  head_bump_db > 0 ? (
    A = exp(head_bump_db * log(10) / 40);
    w0 = 2 * $pi * 90 / srate;
    cosw0 = cos(w0);
    sinw0 = sin(w0);
    alpha = sinw0 / (2 * 0.707);
    beta = sqrt(A) / 0.707;
    
    hb_b0 = A * ((A + 1) - (A - 1) * cosw0 + beta * sinw0);
    hb_b1 = 2 * A * ((A - 1) - (A + 1) * cosw0);
    hb_b2 = A * ((A + 1) - (A - 1) * cosw0 - beta * sinw0);
    a0 = (A + 1) + (A - 1) * cosw0 + beta * sinw0;
    hb_a1 = -2 * ((A - 1) + (A + 1) * cosw0);
    hb_a2 = (A + 1) + (A - 1) * cosw0 - beta * sinw0;
    
    hb_b0 /= a0;
    hb_b1 /= a0;
    hb_b2 /= a0;
    hb_a1 /= a0;
    hb_a2 /= a0;
  ) : (
    hb_b0 = 1;
    hb_b1 = 0;
    hb_b2 = 0;
    hb_a1 = 0;
    hb_a2 = 0;
  );
);

function calculate_hf_rolloff_filter() local(A, w0, cosw0, sinw0, alpha, beta, a0) (
  preset_hf_rolloff_amount < 0 ? (
    A = exp(preset_hf_rolloff_amount * log(10) / 40);
    w0 = 2 * $pi * preset_hf_rolloff_freq / srate;
    cosw0 = cos(w0);
    sinw0 = sin(w0);
    alpha = sinw0 / (2 * 0.707);
    beta = sqrt(A) / 0.707;
    
    hf_b0 = A * ((A + 1) + (A - 1) * cosw0 + beta * sinw0);
    hf_b1 = -2 * A * ((A - 1) + (A + 1) * cosw0);
    hf_b2 = A * ((A + 1) + (A - 1) * cosw0 - beta * sinw0);
    a0 = (A + 1) - (A - 1) * cosw0 + beta * sinw0;
    hf_a1 = 2 * ((A - 1) - (A + 1) * cosw0);
    hf_a2 = (A + 1) - (A - 1) * cosw0 - beta * sinw0;
    
    hf_b0 /= a0;
    hf_b1 /= a0;
    hf_b2 /= a0;
    hf_a1 /= a0;
    hf_a2 /= a0;
  ) : (
    hf_b0 = 1;
    hf_b1 = 0;
    hf_b2 = 0;
    hf_a1 = 0;
    hf_a2 = 0;
  );
);

function update_audio_vars() (
  load_tape_preset(slider7);
  output_gain = exp(slider2 * log(10) / 20) * preset_output_compensation;
  noise_base = exp((slider7 == 4 ? slider3 : preset_noise_floor) * log(10) / 20);
  age_factor = 1 + (slider5 / 100) * 3;
  noise_gain = noise_base * age_factor;
  width_factor = slider6 / 100;
  wow_flutter_amount = slider8 / 100;
  calculate_head_bump_filter();
  calculate_hf_rolloff_filter();
);

// LED meter drawing function
function draw_led_meter(level, x, y, width, height) local(segments, seg_width, seg_spacing, i, seg_x, brightness) (
  segments = 20;
  seg_width = (width - (segments - 1) * 2) / segments;
  seg_spacing = 2;
  
  i = 0;
  while (i < segments) (
    seg_x = x + i * (seg_width + seg_spacing);
    brightness = (i / segments) < level ? 1 : 0.2;
    
    // Color based on level (green -> yellow -> red)
    i < 14 ? (
      // Green
      ui_color(0, 255 * brightness, 0);
    ) : i < 17 ? (
      // Yellow
      ui_color(255 * brightness, 255 * brightness, 0);
    ) : (
      // Red
      ui_color(255 * brightness, 0, 0);
    );
    
    ui_push();
      ui_set_rect(seg_x, y, seg_width, height);
      ui_fill();
    ui_pop();
    
    i += 1;
  );
);

update_audio_vars();

@slider
update_audio_vars();

@sample
effective_saturation = slider1 * preset_sat_character;

effective_saturation > 0 ? (
  sat_amount = (effective_saturation / 200) * $pi;
  sat_norm = sin((effective_saturation / 200) * $pi);
  
  slider7 == 0 ? (
    spl0 = min(max(sin(max(min(spl0, 1), -1) * sat_amount) / sat_norm + spl0 * spl0 * 0.1, -1), 1);
    spl1 = min(max(sin(max(min(spl1, 1), -1) * sat_amount) / sat_norm + spl1 * spl1 * 0.1, -1), 1);
  ) : slider7 == 1 ? (
    spl0 = min(max(sin(max(min(spl0, 1), -1) * sat_amount) / sat_norm + spl0 * spl0 * spl0 * 0.15, -1), 1);
    spl1 = min(max(sin(max(min(spl1, 1), -1) * sat_amount) / sat_norm + spl1 * spl1 * spl1 * 0.15, -1), 1);
  ) : slider7 == 2 ? (
    spl0 = min(max(sin(max(min(spl0, 1), -1) * sat_amount) / sat_norm + spl0 * spl0 * 0.05, -1), 1);
    spl1 = min(max(sin(max(min(spl1, 1), -1) * sat_amount) / sat_norm + spl1 * spl1 * 0.05, -1), 1);
  ) : slider7 == 3 ? (
    spl0 = min(max(sin(max(min(spl0, 1), -1) * sat_amount) / sat_norm + spl0 * spl0 * 0.08 + spl0 * spl0 * spl0 * 0.05, -1), 1);
    spl1 = min(max(sin(max(min(spl1, 1), -1) * sat_amount) / sat_norm + spl1 * spl1 * 0.08 + spl1 * spl1 * spl1 * 0.05, -1), 1);
  ) : (
    spl0 = min(max(sin(max(min(spl0, 1), -1) * sat_amount) / sat_norm, -1), 1);
    spl1 = min(max(sin(max(min(spl1, 1), -1) * sat_amount) / sat_norm, -1), 1);
  );
);

// Update input meters
abs(spl0) > input_peak_l ? input_peak_l = abs(spl0) : input_peak_l *= meter_decay;
abs(spl1) > input_peak_r ? input_peak_r = abs(spl1) : input_peak_r *= meter_decay;

noise = rand(2) - 1;

slider7 == 0 ? (
  noise = noise * 0.8 + sin(noise * $pi) * 0.2;
) : slider7 == 1 ? (
  noise = noise + noise * noise * noise * 0.3;
) : slider7 == 3 ? (
  noise = noise * 0.9 + sin(noise * $pi * 0.5) * 0.1;
);

slider5 > 0 ? (
  age_dropout_counter += 1;
  age_dropout_counter > srate / 20 ? (
    age_dropout_counter = 0;
    dropout_chance = slider5 / 100 * 0.01;
    rand() < dropout_chance ? (
      dropout_length = floor(rand() * srate * 0.05);
      dropout_counter = dropout_length;
    );
  );
  
  dropout_counter > 0 ? (
    dropout_factor = 0.05 + rand() * 0.2;
    spl0 *= dropout_factor;
    spl1 *= dropout_factor;
    dropout_counter -= 1;
  );
  
  age_mod = sin(age_noise_seed * 0.01) * slider5 / 100 * 0.001;
  age_noise_seed += 1;
  noise += age_mod;
);

wow_flutter_amount > 0 ? (
  wf_buffer_l[wf_write_pos] = spl0;
  wf_buffer_r[wf_write_pos] = spl1;
  
  wow_phase += 0.5 / srate;
  wow_phase >= 1 ? wow_phase -= 1;
  
  flutter_phase += 12 / srate;
  flutter_phase >= 1 ? flutter_phase -= 1;
  
  wow_mod = sin(2 * $pi * wow_phase);
  flutter_mod = sin(2 * $pi * flutter_phase);
  total_modulation = wow_flutter_amount * (wow_mod * 0.0001 + flutter_mod * 0.00005);
  
  base_delay = 256;
  read_offset = base_delay * (1 + total_modulation);
  read_pos = wf_write_pos - read_offset;
  read_pos < 0 ? read_pos += wf_buffer_size;
  
  read_pos_int = floor(read_pos);
  read_pos_frac = read_pos - read_pos_int;
  read_pos_next = (read_pos_int + 1) % wf_buffer_size;
  
  spl0 = wf_buffer_l[read_pos_int] * (1 - read_pos_frac) + wf_buffer_l[read_pos_next] * read_pos_frac;
  spl1 = wf_buffer_r[read_pos_int] * (1 - read_pos_frac) + wf_buffer_r[read_pos_next] * read_pos_frac;
  
  wf_write_pos = (wf_write_pos + 1) % wf_buffer_size;
);

spl0 = spl0 * output_gain + noise * noise_gain;
spl1 = spl1 * output_gain + noise * noise_gain;

head_bump_db > 0 ? (
  hb_out_l = hb_b0 * spl0 + hb_b1 * hb_x1_l + hb_b2 * hb_x2_l - hb_a1 * hb_y1_l - hb_a2 * hb_y2_l;
  hb_x2_l = hb_x1_l;
  hb_x1_l = spl0;
  hb_y2_l = hb_y1_l;
  hb_y1_l = hb_out_l;
  spl0 = hb_out_l;
  
  hb_out_r = hb_b0 * spl1 + hb_b1 * hb_x1_r + hb_b2 * hb_x2_r - hb_a1 * hb_y1_r - hb_a2 * hb_y2_r;
  hb_x2_r = hb_x1_r;
  hb_x1_r = spl1;
  hb_y2_r = hb_y1_r;
  hb_y1_r = hb_out_r;
  spl1 = hb_out_r;
);

preset_hf_rolloff_amount < 0 ? (
  hf_out_l = hf_b0 * spl0 + hf_b1 * hf_x1_l + hf_b2 * hf_x2_l - hf_a1 * hf_y1_l - hf_a2 * hf_y2_l;
  hf_x2_l = hf_x1_l;
  hf_x1_l = spl0;
  hf_y2_l = hf_y1_l;
  hf_y1_l = hf_out_l;
  spl0 = hf_out_l;
  
  hf_out_r = hf_b0 * spl1 + hf_b1 * hf_x1_r + hf_b2 * hf_x2_r - hf_a1 * hf_y1_r - hf_a2 * hf_y2_r;
  hf_x2_r = hf_x1_r;
  hf_x1_r = spl1;
  hf_y2_r = hf_y1_r;
  hf_y1_r = hf_out_r;
  spl1 = hf_out_r;
);

mid = (spl0 + spl1) * 0.5;
side = (spl0 - spl1) * 0.5;
side *= width_factor;

slider7 == 0 ? (
  mid *= 1.02;
  side *= 0.98;
) : slider7 == 1 ? (
  mid = mid + mid * mid * 0.01;
  side *= 1.05;
) : slider7 == 3 ? (
  mid *= 1.01;
);

spl0 = mid + side;
spl1 = mid - side;

// Update output meters
abs(spl0) > output_peak_l ? output_peak_l = abs(spl0) : output_peak_l *= meter_decay;
abs(spl1) > output_peak_r ? output_peak_r = abs(spl1) : output_peak_r *= meter_decay;

@gfx 650 330

control_start("main", "tron");

ui_pad(10, 10);

// Header
ui_split_top(35);
  ui_fontface("Trebuchet MS");
  ui_fontsize(28);
  ui_color(255, 255, 255);
  ui_align(0.5, 0.5);
  ui_text("TapeEmu: Classic Tape Machine Emulation");
ui_pop();

ui_padtop(15);

// Machine selector tabs
ui_split_top(40);
  button_width = ui_width() / 5;
  
  // Basic Tape
  ui_split_left(button_width);
    is_selected = (slider7 == 4);
    is_selected ? (
      control_background_inset();
      ui_color(0, 255, 0);
      ui_push();
        ui_align(0.5, 0.2);
        ui_push_height(6);
          ui_push_width(6);
            ui_fill();
          ui_pop();
        ui_pop();
      ui_pop();
    ) : control_background_enabled("none");
    
    ui_color(255, 255, 255);
    ui_align(0.5, 0.6);
    ui_fontsize(11);
    ui_text("BASIC TAPE");
    
    is_selected ? control_finish_inset() : control_finish_enabled("none");
    
    ui_click() ? (
      slider7 = 4;
      sliderchange(slider7);
      update_audio_vars();
    );
  ui_pop();
  
  // Studer A800
  ui_split_left(button_width);
    is_selected = (slider7 == 0);
    is_selected ? (
      control_background_inset();
      ui_color(0, 255, 0);
      ui_push();
        ui_align(0.5, 0.2);
        ui_push_height(6);
          ui_push_width(6);
            ui_fill();
          ui_pop();
        ui_pop();
      ui_pop();
    ) : control_background_enabled("none");
    
    ui_color(255, 255, 255);
    ui_align(0.5, 0.6);
    ui_fontsize(11);
    ui_text("STUDER A800");
    
    is_selected ? control_finish_inset() : control_finish_enabled("none");
    
    ui_click() ? (
      slider7 = 0;
      sliderchange(slider7);
      update_audio_vars();
    );
  ui_pop();
  
  // Ampex ATR102
  ui_split_left(button_width);
    is_selected = (slider7 == 1);
    is_selected ? (
      control_background_inset();
      ui_color(0, 255, 0);
      ui_push();
        ui_align(0.5, 0.2);
        ui_push_height(6);
          ui_push_width(6);
            ui_fill();
          ui_pop();
        ui_pop();
      ui_pop();
    ) : control_background_enabled("none");
    
    ui_color(255, 255, 255);
    ui_align(0.5, 0.6);
    ui_fontsize(11);
    ui_text("AMPEX ATR102");
    
    is_selected ? control_finish_inset() : control_finish_enabled("none");
    
    ui_click() ? (
      slider7 = 1;
      sliderchange(slider7);
      update_audio_vars();
    );
  ui_pop();
  
  // Sony APR5000
  ui_split_left(button_width);
    is_selected = (slider7 == 2);
    is_selected ? (
      control_background_inset();
      ui_color(0, 255, 0);
      ui_push();
        ui_align(0.5, 0.2);
        ui_push_height(6);
          ui_push_width(6);
            ui_fill();
          ui_pop();
        ui_pop();
      ui_pop();
    ) : control_background_enabled("none");
    
    ui_color(255, 255, 255);
    ui_align(0.5, 0.6);
    ui_fontsize(11);
    ui_text("SONY APR5000");
    
    is_selected ? control_finish_inset() : control_finish_enabled("none");
    
    ui_click() ? (
      slider7 = 2;
      sliderchange(slider7);
      update_audio_vars();
    );
  ui_pop();
  
  // Otari MTR90
  ui_split_left(button_width);
    is_selected = (slider7 == 3);
    is_selected ? (
      control_background_inset();
      ui_color(0, 255, 0);
      ui_push();
        ui_align(0.5, 0.2);
        ui_push_height(6);
          ui_push_width(6);
            ui_fill();
          ui_pop();
        ui_pop();
      ui_pop();
    ) : control_background_enabled("none");
    
    ui_color(255, 255, 255);
    ui_align(0.5, 0.6);
    ui_fontsize(11);
    ui_text("OTARI MTR90");
    
    is_selected ? control_finish_inset() : control_finish_enabled("none");
    
    ui_click() ? (
      slider7 = 3;
      sliderchange(slider7);
      update_audio_vars();
    );
  ui_pop();
ui_pop();

ui_padtop(25);

// Knobs section
ui_split_top(120);
  knob_width = ui_width() / 7;
  
  // INPUT
  ui_split_left(knob_width);
    ui_push();
      ui_pad(5, 5);
      ui_split_bottom(30);
        ui_align(0.5, 0.5);
        ui_fontsize(10);
        ui_color(255, 255, 255);
        ui_text("INPUT");
      ui_pop();
      ui_automate(slider1, control_dial(slider1, 0, 178, 0, 0));
    ui_pop();
  ui_pop();
  
  // OUTPUT
  ui_split_left(knob_width);
    ui_push();
      ui_pad(5, 5);
      ui_split_bottom(30);
        ui_align(0.5, 0.5);
        ui_fontsize(10);
        ui_color(255, 255, 255);
        ui_text("OUTPUT");
      ui_pop();
      ui_automate(slider2, control_dial(slider2, -50, 0, 0, 0));
    ui_pop();
  ui_pop();
  
  // NOISE (dimmed if preset active)
  ui_split_left(knob_width);
    ui_push();
      ui_pad(5, 5);
      ui_split_bottom(30);
        ui_align(0.5, 0.5);
        ui_fontsize(10);
        slider7 != 4 ? ui_color(128, 128, 128) : ui_color(255, 255, 255);
        ui_text("NOISE");
      ui_pop();
      slider7 != 4 ? (
        ui_push();
          ui_color(128, 128, 128, 0.5);
          control_dial(preset_noise_floor, -105, -60, 0, -105);
        ui_pop();
      ) : (
        ui_automate(slider3, control_dial(slider3, -105, -60, 0, -105));
      );
    ui_pop();
  ui_pop();
  
  // HEAD BUMP (dimmed if preset active)
  ui_split_left(knob_width);
    ui_push();
      ui_pad(5, 5);
      ui_split_bottom(30);
        ui_align(0.5, 0.5);
        ui_fontsize(10);
        slider7 != 4 ? ui_color(128, 128, 128) : ui_color(255, 255, 255);
        ui_text("HEAD BUMP");
      ui_pop();
      slider7 != 4 ? (
        ui_push();
          ui_color(128, 128, 128, 0.5);
          control_dial(preset_head_bump, 0, 18, 0, 0);
        ui_pop();
      ) : (
        ui_automate(slider4, control_dial(slider4, 0, 18, 0, 0));
      );
    ui_pop();
  ui_pop();
  
  // TAPE AGE
  ui_split_left(knob_width);
    ui_push();
      ui_pad(5, 5);
      ui_split_bottom(30);
        ui_align(0.5, 0.5);
        ui_fontsize(10);
        ui_color(255, 255, 255);
        ui_text("TAPE AGE");
      ui_pop();
      ui_automate(slider5, control_dial(slider5, 0, 100, 0, 0));
    ui_pop();
  ui_pop();
  
  // STEREO WIDTH
  ui_split_left(knob_width);
    ui_push();
      ui_pad(5, 5);
      ui_split_bottom(30);
        ui_align(0.5, 0.5);
        ui_fontsize(9);
        ui_color(255, 255, 255);
        ui_text("STEREO WIDTH");
      ui_pop();
      ui_automate(slider6, control_dial(slider6, 0, 200, 0, 100));
    ui_pop();
  ui_pop();
  
  // WOW & FLUTTER
  ui_split_left(knob_width);
    ui_push();
      ui_pad(5, 5);
      ui_split_bottom(30);
        ui_align(0.5, 0.5);
        ui_fontsize(9);
        ui_color(255, 255, 255);
        ui_text("WOW & FLUTTER");
      ui_pop();
      ui_automate(slider8, control_dial(slider8, 0, 100, 0, 0));
    ui_pop();
  ui_pop();
ui_pop();

ui_padtop(5);

// Meters section
ui_split_bottom(50);
  ui_pad(10, 5);
  
  // Input meter
  ui_split_top(18);
    ui_split_left(60);
      ui_align(1, 0.5);
      ui_fontsize(10);
      ui_color(255, 255, 255);
      ui_text("INPUT");
    ui_pop();
    ui_padleft(10);
    draw_led_meter(max(input_peak_l, input_peak_r), ui_left(), ui_top(), ui_width(), ui_height());
  ui_pop();
  
  ui_padtop(8);
  
  // Output meter
  ui_split_top(18);
    ui_split_left(60);
      ui_align(1, 0.5);
      ui_fontsize(10);
      ui_color(255, 255, 255);
      ui_text("OUTPUT");
    ui_pop();
    ui_padleft(10);
    draw_led_meter(max(output_peak_l, output_peak_r), ui_left(), ui_top(), ui_width(), ui_height());
  ui_pop();
ui_pop();