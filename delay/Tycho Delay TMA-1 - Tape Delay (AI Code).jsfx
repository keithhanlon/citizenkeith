desc: Tycho Delay TMA-1
version: 2.0
author: citizenkeith
about:
  Good quality tape-style delay with optimized memory layout and ping pong.
  Based on work by LOSER (JS:Saturation) and Cockos (JS:Delay) with additional code from Sault.
  Ping pong functionality inspired by Stillwell. Memory layout optimized by Claude AI.
  Released under GPLv3 license.
changelog:
  # v2.0
  + Complete GUI overhaul using citizenkeith-ui-lib
  + Sync on/off toggle — preserves last sync value when toggled off
  + Removed Off option from sync selector; dedicated SYNC button added
  + Red readout for active sync value
  + Fixed ui_setup memory overlap causing periodic clicks and GUI flashing
  + Cleaned up dead code from troubleshooting (delaylen, init flags, @block tempo tracking)
  # v1.0
  + Initial release with cubic interpolation delay buffer
  + Catmull-Rom interpolation for smooth delay time changes
  + Ping pong stereo with crossfade
  + Delay loop lowpass filter and saturation
  + Tempo sync with 28 note values
// @provides
//   [nomain] ../citizenkeith-ui-lib/citizenkeith-ui-lib.jsfx-inc
// @license GPL v3

import citizenkeith-ui-lib.jsfx-inc

slider10:400<1,80000,1>-Delay (ms)
slider11:1<1,28,1{1/32,1/16T,1/32D,1/16,1/8T,1/16D,1/8,1/4T,1/8D,1/4,1/2T,1/4D,1/2,1T,1/2D,1,2T,1D,2,4T,2D,4,8T,4D,8,16T,8D,16}>-Delay (sync)
slider12:0.5<0,1,0.01>-Mix
slider38:0<0,1,1>-Sync On
slider20:0<-90,15,0.1>-Input Gain (dB)
slider21:-4<-90,15,0.1>-Feedback (dB)
slider30:10000<1000,15000,1>-Delay Loop Lowpass (Hz)
slider35:1<1,100,1>-Delay Loop Saturation (%)
slider37:0<0,100,1>-Ping Pong Width (%)
slider50:0<-30,30,0.1>-Volume (dB)

options:gfx_hz=60

@init

// Memory layout
max_delay_samples = 65536;
buffer_size_stereo = max_delay_samples * 2;
buffer_mask_stereo = buffer_size_stereo - 1;

delay_buffer_base = 1000;
delay_buffer = delay_buffer_base + (64 - (delay_buffer_base % 64));

write_pos = 0;
current_delay_samples = 0;
target_delay_samples = 0;

PINGPONG_SWITCH_ZONE = 400;
ping_pong_state = 0;
delay_position = 0;

coeff_table_size = 256;
coeff_table_mask = coeff_table_size - 1;

coeff_table_base = delay_buffer + buffer_size_stereo + 100;
coeff_table = coeff_table_base + (64 - (coeff_table_base % 64));

i = 0;
loop(coeff_table_size,
  t = i / coeff_table_size;
  t2 = t * t;
  t3 = t2 * t;

  coeff_table[i * 4 + 0] = 0.5 * (-t + 2*t2 - t3);
  coeff_table[i * 4 + 1] = 0.5 * (2 - 5*t2 + 3*t3);
  coeff_table[i * 4 + 2] = 0.5 * (t + 4*t2 - 3*t3);
  coeff_table[i * 4 + 3] = 0.5 * (-t2 + t3);
  i += 1;
);

delay_smooth_coeff = exp(-2 * $pi * 20 / srate);
gain_smooth_coeff = exp(-2 * $pi * 30 / srate);
filter_smooth_coeff = exp(-2 * $pi * 25 / srate);
saturation_smooth_coeff = exp(-2 * $pi * 15 / srate);

smooth_input_gain = 1;
smooth_feedback = 0.631;
smooth_volume = 1;
smooth_mix = 0.5;
smooth_filter_freq = 10000;
smooth_delay_sat = 1;
smooth_pingpong_width = 0;

target_input_gain = 1;
target_feedback = 0.631;
target_volume = 1;
target_mix = 0.5;
target_filter_freq = 10000;
target_delay_sat = 1;
target_pingpong_width = 0;

oslider10 = 0;
oslider11 = slider11;
sync_on = 0;

last_filter_freq = 10000;
last_delay_sat = 1;

// Helper functions
function draw_label_at(cx, cy) (
  gfx_setfont(1, "Arial", 11);
  gfx_measurestr(#lbl, lbl_w, lbl_h);
  gfx_x = cx - lbl_w/2;
  gfx_y = cy;
  gfx_drawstr(#lbl);
);

function draw_value_at(cx, cy) (
  gfx_setfont(1, "Arial", 14);
  gfx_measurestr(#val, val_w, val_h);
  gfx_x = cx - val_w/2;
  gfx_y = cy;
  gfx_drawstr(#val);
);

function draw_knob_inactive(cx, cy, radius, value, vmin, vmax) local(ratio, angle, x1, y1, x2, y2) (
  gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.32; gfx_a = 1;
  gfx_circle(cx, cy, radius, 1, 1);

  ratio = (value - vmin) / (vmax - vmin);
  angle = -2.3 + 4.6 * ratio;
  x1 = cx + sin(angle) * radius * 0.3;
  y1 = cy - cos(angle) * radius * 0.3;
  x2 = cx + sin(angle) * radius * 0.8;
  y2 = cy - cos(angle) * radius * 0.8;

  gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.52; gfx_a = 1;
  gfx_line(x1, y1, x2, y2, 1);
);

function clear_buffer() local(clear_samples, i) (
  current_delay_samples > 0 ? (
    clear_samples = min(current_delay_samples * 2, buffer_size_stereo);
    i = 0;
    loop(clear_samples / 8,
      delay_buffer[i] = 0; delay_buffer[i+1] = 0;
      delay_buffer[i+2] = 0; delay_buffer[i+3] = 0;
      delay_buffer[i+4] = 0; delay_buffer[i+5] = 0;
      delay_buffer[i+6] = 0; delay_buffer[i+7] = 0;
      i += 8;
    );
    loop(clear_samples & 7,
      delay_buffer[i] = 0;
      i += 1;
    );
  );
  write_pos = 0;
  delay_position = 0;
);

function catmull_rom_interp_fast(p0, p1, p2, p3, t) local(table_index, c0, c1, c2, c3) (
  table_index = (t * coeff_table_size) & coeff_table_mask;
  table_index *= 4;

  c0 = coeff_table[table_index];
  c1 = coeff_table[table_index + 1];
  c2 = coeff_table[table_index + 2];
  c3 = coeff_table[table_index + 3];

  p0 * c0 + p1 * c1 + p2 * c2 + p3 * c3;
);

function cubic_delay_read(delay_samples) local(int_delay, frac_delay, base_pos) (
  int_delay = floor(delay_samples);
  frac_delay = delay_samples - int_delay;

  base_pos = (write_pos - (int_delay * 2)) & buffer_mask_stereo;

  pos0 = (base_pos - 2) & buffer_mask_stereo;
  p0l = delay_buffer[pos0];
  p0r = delay_buffer[pos0 + 1];

  p1l = delay_buffer[base_pos];
  p1r = delay_buffer[base_pos + 1];

  pos2 = (base_pos + 2) & buffer_mask_stereo;
  p2l = delay_buffer[pos2];
  p2r = delay_buffer[pos2 + 1];

  pos3 = (base_pos + 4) & buffer_mask_stereo;
  p3l = delay_buffer[pos3];
  p3r = delay_buffer[pos3 + 1];

  this.left = catmull_rom_interp_fast(p0l, p1l, p2l, p3l, frac_delay);
  this.right = catmull_rom_interp_fast(p0r, p1r, p2r, p3r, frac_delay);
);

function buffer_write(left, right) (
  delay_buffer[write_pos] = left;
  delay_buffer[write_pos + 1] = right;
  write_pos = (write_pos + 2) & buffer_mask_stereo;
);

tanh_a = 27/32;
tanh_b = 1;

function fast_tanh(x) (
  x2 = x * x;
  x * (tanh_a + x2) / (tanh_b + tanh_a * x2);
);

function setdrive(drive_percent) (
  this.drive = 1 + (drive_percent * 0.09);
  this.makeup = 1 / this.drive;
);

function saturate_stereo(left, right) instance(drive, makeup) (
  left = max(-2, min(2, left));
  right = max(-2, min(2, right));

  this.left = fast_tanh(left * drive) * makeup;
  this.right = fast_tanh(right * drive) * makeup;
);

DENORMAL_OFFSET = 0.000000000001;

function bq_setlp(freq) (
  omega = 2 * $pi * freq / srate;
  cos_omega = cos(omega);
  sin_omega = sin(omega);

  q = 0.5;
  alpha = sin_omega / (2 * q);

  b0 = (1 - cos_omega) * 0.5;
  b1 = 1 - cos_omega;
  b2 = b0;
  a0 = 1 + alpha;
  a1 = -2 * cos_omega;
  a2 = 1 - alpha;

  this.b0 = (b0 / a0) + DENORMAL_OFFSET;
  this.b1 = (b1 / a0) + DENORMAL_OFFSET;
  this.b2 = (b2 / a0) + DENORMAL_OFFSET;
  this.a1 = (a1 / a0) + DENORMAL_OFFSET;
  this.a2 = (a2 / a0) + DENORMAL_OFFSET;
);

function bq_lp_stereo(left, right) instance(
  b0, b1, b2, a1, a2,
  xl1, xl2, yl1, yl2,
  xr1, xr2, yr1, yr2
) (
  this.left = b0 * left + b1 * xl1 + b2 * xl2 - a1 * yl1 - a2 * yl2;
  this.right = b0 * right + b1 * xr1 + b2 * xr2 - a1 * yr1 - a2 * yr2;

  abs(this.left) < DENORMAL_OFFSET ? this.left = 0;
  abs(this.right) < DENORMAL_OFFSET ? this.right = 0;

  xl2 = xl1; xl1 = left;
  yl2 = yl1; yl1 = this.left;
  xr2 = xr1; xr1 = right;
  yr2 = yr1; yr1 = this.right;
);

function calculate_sync_time(sync_index) local(beats, ms_per_beat) (
  ms_per_beat = 60000 / tempo;

  sync_index == 1 ? beats = 1/8 :
  sync_index == 2 ? beats = 1/6 :
  sync_index == 3 ? beats = 3/16 :
  sync_index == 4 ? beats = 1/4 :
  sync_index == 5 ? beats = 1/3 :
  sync_index == 6 ? beats = 3/8 :
  sync_index == 7 ? beats = 1/2 :
  sync_index == 8 ? beats = 2/3 :
  sync_index == 9 ? beats = 3/4 :
  sync_index == 10 ? beats = 1 :
  sync_index == 11 ? beats = 4/3 :
  sync_index == 12 ? beats = 1.5 :
  sync_index == 13 ? beats = 2 :
  sync_index == 14 ? beats = 8/3 :
  sync_index == 15 ? beats = 3 :
  sync_index == 16 ? beats = 4 :
  sync_index == 17 ? beats = 16/3 :
  sync_index == 18 ? beats = 6 :
  sync_index == 19 ? beats = 8 :
  sync_index == 20 ? beats = 32/3 :
  sync_index == 21 ? beats = 12 :
  sync_index == 22 ? beats = 16 :
  sync_index == 23 ? beats = 64/3 :
  sync_index == 24 ? beats = 24 :
  sync_index == 25 ? beats = 32 :
  sync_index == 26 ? beats = 128/3 :
  sync_index == 27 ? beats = 48 :
  sync_index == 28 ? beats = 64 :
  beats = 1;

  beats * ms_per_beat;
);

function get_sync_name(sync_index) (
  sync_index == 1 ? "1/32" :
  sync_index == 2 ? "1/16T" :
  sync_index == 3 ? "1/32D" :
  sync_index == 4 ? "1/16" :
  sync_index == 5 ? "1/8T" :
  sync_index == 6 ? "1/16D" :
  sync_index == 7 ? "1/8" :
  sync_index == 8 ? "1/4T" :
  sync_index == 9 ? "1/8D" :
  sync_index == 10 ? "1/4" :
  sync_index == 11 ? "1/2T" :
  sync_index == 12 ? "1/4D" :
  sync_index == 13 ? "1/2" :
  sync_index == 14 ? "1T" :
  sync_index == 15 ? "1/2D" :
  sync_index == 16 ? "1" :
  sync_index == 17 ? "2T" :
  sync_index == 18 ? "1D" :
  sync_index == 19 ? "2" :
  sync_index == 20 ? "4T" :
  sync_index == 21 ? "2D" :
  sync_index == 22 ? "4" :
  sync_index == 23 ? "8T" :
  sync_index == 24 ? "4D" :
  sync_index == 25 ? "8" :
  sync_index == 26 ? "16T" :
  sync_index == 27 ? "8D" :
  sync_index == 28 ? "16" :
  "1/32";
);

// Initialize filters and buffers
aa_freq = min(srate * 0.4, 20000);
input_aa_filter.bq_setlp(aa_freq);
output_aa_filter.bq_setlp(aa_freq);
delay_loop_filter.bq_setlp(smooth_filter_freq);
delaysat.setdrive(smooth_delay_sat);

// Initialize filter state variables
input_aa_filter.xl1 = input_aa_filter.xl2 = input_aa_filter.yl1 = input_aa_filter.yl2 = 0;
input_aa_filter.xr1 = input_aa_filter.xr2 = input_aa_filter.yr1 = input_aa_filter.yr2 = 0;

output_aa_filter.xl1 = output_aa_filter.xl2 = output_aa_filter.yl1 = output_aa_filter.yl2 = 0;
output_aa_filter.xr1 = output_aa_filter.xr2 = output_aa_filter.yr1 = output_aa_filter.yr2 = 0;

delay_loop_filter.xl1 = delay_loop_filter.xl2 = delay_loop_filter.yl1 = delay_loop_filter.yl2 = 0;
delay_loop_filter.xr1 = delay_loop_filter.xr2 = delay_loop_filter.yr1 = delay_loop_filter.yr2 = 0;

// Clear delay buffer
i = 0;
loop(buffer_size_stereo,
  delay_buffer[i] = 0;
  i += 1;
);

// Initialize delay time
target_delay_samples = min(floor(srate * 0.001 * slider10), max_delay_samples - 4);
current_delay_samples = target_delay_samples;

// UI setup — placed after all memory allocations to avoid overlap
ui_setup(200000);

@slider

(abs(oslider10 - slider10) > 0.1 || oslider11 != slider11 || sync_on != slider38) ? (
  sync_on = slider38;

  (oslider11 != slider11) ? (
    oslider11 = slider11;
  );

  sync_on ? (
    new_sync_time = calculate_sync_time(slider11);
    abs(new_sync_time - slider10) > 0.5 ? slider10 = new_sync_time;
  );

  target_delay_samples = min(floor(srate * 0.001 * slider10), max_delay_samples - 4);
  oslider10 = slider10;

  abs(target_delay_samples - current_delay_samples) > (srate * 0.5) ? clear_buffer();
);

target_input_gain = 10^(slider20/20);
target_feedback = 10^(slider21/20);
target_volume = 10^(slider50/20);
target_mix = slider12;
target_filter_freq = slider30;
target_delay_sat = slider35;
target_pingpong_width = slider37 / 100.0;
sync_on = slider38;

@sample

current_delay_samples = target_delay_samples + (current_delay_samples - target_delay_samples) * delay_smooth_coeff;

param_change_mask = 0;

abs(target_input_gain - smooth_input_gain) > 0.001 ? param_change_mask |= 1;
abs(target_feedback - smooth_feedback) > 0.001 ? param_change_mask |= 2;
abs(target_volume - smooth_volume) > 0.001 ? param_change_mask |= 4;
abs(target_mix - smooth_mix) > 0.001 ? param_change_mask |= 8;
abs(target_filter_freq - smooth_filter_freq) > 10.0 ? param_change_mask |= 16;
abs(target_delay_sat - smooth_delay_sat) > 0.1 ? param_change_mask |= 32;
abs(target_pingpong_width - smooth_pingpong_width) > 0.01 ? param_change_mask |= 64;

param_change_mask & 1 ? smooth_input_gain = target_input_gain + (smooth_input_gain - target_input_gain) * gain_smooth_coeff;
param_change_mask & 2 ? smooth_feedback = target_feedback + (smooth_feedback - target_feedback) * gain_smooth_coeff;
param_change_mask & 4 ? smooth_volume = target_volume + (smooth_volume - target_volume) * gain_smooth_coeff;
param_change_mask & 8 ? smooth_mix = target_mix + (smooth_mix - target_mix) * gain_smooth_coeff;
param_change_mask & 16 ? smooth_filter_freq = target_filter_freq + (smooth_filter_freq - target_filter_freq) * filter_smooth_coeff;
param_change_mask & 32 ? smooth_delay_sat = target_delay_sat + (smooth_delay_sat - target_delay_sat) * saturation_smooth_coeff;
param_change_mask & 64 ? smooth_pingpong_width = target_pingpong_width + (smooth_pingpong_width - target_pingpong_width) * gain_smooth_coeff;

abs(smooth_filter_freq - last_filter_freq) > 10 ? (
  delay_loop_filter.bq_setlp(smooth_filter_freq);
  last_filter_freq = smooth_filter_freq;
);

abs(smooth_delay_sat - last_delay_sat) > 0.1 ? (
  delaysat.setdrive(smooth_delay_sat);
  last_delay_sat = smooth_delay_sat;
);

input_aa_filter.bq_lp_stereo(spl0, spl1);
lp_spl0 = input_aa_filter.left;
lp_spl1 = input_aa_filter.right;

current_delay_samples >= 4 ? (
  delayed_samples.cubic_delay_read(current_delay_samples);
  delayed0 = delayed_samples.left;
  delayed1 = delayed_samples.right;

  delaysat.saturate_stereo(delayed0, delayed1);
  delayed0 = delaysat.left;
  delayed1 = delaysat.right;

  delay_loop_filter.bq_lp_stereo(delayed0, delayed1);
  delayed0 = delay_loop_filter.left;
  delayed1 = delay_loop_filter.right;

  buffer_input0 = delayed0 * smooth_feedback + lp_spl0 * smooth_input_gain;
  buffer_input1 = delayed1 * smooth_feedback + lp_spl1 * smooth_input_gain;

  buffer_write(buffer_input0, buffer_input1);

  smooth_pingpong_width > 0 ? (
    abs(delay_position) < PINGPONG_SWITCH_ZONE ? (
      switch_factor = ping_pong_state ?
        abs(delay_position) / PINGPONG_SWITCH_ZONE :
        (PINGPONG_SWITCH_ZONE - abs(delay_position)) / PINGPONG_SWITCH_ZONE;
    ) : (
      switch_factor = ping_pong_state;
    );

    delay_position += 1;
    delay_position >= current_delay_samples ? (
      delay_position = 0;
      ping_pong_state = 1 - ping_pong_state;
    );

    delayed_mono = (delayed0 + delayed1) * 0.5;

    ping_pong_pan_base = (1 - smooth_pingpong_width) * 0.5;
    ping_pong_pan_position = ping_pong_pan_base + smooth_pingpong_width * switch_factor;

    delayed0 = delayed_mono * sqrt(1 - ping_pong_pan_position);
    delayed1 = delayed_mono * sqrt(ping_pong_pan_position);
  ) : (
    delay_position += 1;
    delay_position >= current_delay_samples ? delay_position = 0;
  );

) : (
  delayed0 = delayed1 = 0;
  buffer_write(lp_spl0 * smooth_input_gain, lp_spl1 * smooth_input_gain);
  delay_position = 0;
  ping_pong_state = 0;
);

output0 = (spl0 * (1 - smooth_mix) + delayed0 * smooth_mix) * smooth_volume;
output1 = (spl1 * (1 - smooth_mix) + delayed1 * smooth_mix) * smooth_volume;

output_aa_filter.bq_lp_stereo(output0, output1);
spl0 = output_aa_filter.left;
spl1 = output_aa_filter.right;

@gfx 672 600

control_start("main", "tron");

ui_screen() == "main" ? (

// Background
gfx_r = 0.235; gfx_g = 0.235; gfx_b = 0.255; gfx_a = 1;
gfx_rect(0, 0, gfx_w, gfx_h);

// Title
gfx_r = 1.0; gfx_g = 1.0; gfx_b = 1.0; gfx_a = 1;
gfx_setfont(1, "Trebuchet MS", 28);
gfx_measurestr("Tycho Tape Delay TMA-1", title_w, title_h);
gfx_x = (gfx_w - title_w) / 2;
gfx_y = 20;
gfx_drawstr("Tycho Tape Delay TMA-1");

// Divider lines
gfx_r = 0.28; gfx_g = 0.28; gfx_b = 0.32; gfx_a = 1;
gfx_rect(40, 230, 592, 1);
gfx_rect(40, 410, 592, 1);

// Knob positions
row1_y = 140;
row2_y = 320;
row3_y = 500;
col1_x = 120;
col2_x = 320;
col3_x = 520;

delay_is_synced = sync_on;

// ROW 1: INPUT, OUTPUT, MIX

// INPUT
ui_push_rect(col1_x - 35, row1_y - 35, 70, 70);
new_val = control_dial(slider20, -90, 15, 0, 0);
(ui_drag() || ui_click()) ? slider20 = new_val;
ui_pop();
strcpy(#lbl, "INPUT");  draw_label_at(col1_x, row1_y - 49);
sprintf(#val, "%+.1f dB", slider20);  draw_value_at(col1_x, row1_y + 39);

// OUTPUT
ui_push_rect(col2_x - 35, row1_y - 35, 70, 70);
new_val = control_dial(slider50, -30, 30, 0, 0);
(ui_drag() || ui_click()) ? slider50 = new_val;
ui_pop();
strcpy(#lbl, "OUTPUT");  draw_label_at(col2_x, row1_y - 49);
sprintf(#val, "%+.1f dB", slider50);  draw_value_at(col2_x, row1_y + 39);

// MIX
ui_push_rect(col3_x - 35, row1_y - 35, 70, 70);
new_val = control_dial(slider12, 0, 1, 0, 0.5);
(ui_drag() || ui_click()) ? slider12 = new_val;
ui_pop();
strcpy(#lbl, "MIX");  draw_label_at(col3_x, row1_y - 49);
sprintf(#val, "%.0f%%", slider12 * 100);  draw_value_at(col3_x, row1_y + 39);

// ROW 2: DELAY, FEEDBACK, PING PONG

// DELAY (grayed out when synced)
delay_is_synced ? (
  draw_knob_inactive(col1_x, row2_y, 35, slider10, 1, 80000);
  gfx_r = 0.38; gfx_g = 0.38; gfx_b = 0.40; gfx_a = 1;
) : (
  ui_push_rect(col1_x - 35, row2_y - 35, 70, 70);
  new_val = control_dial(slider10, 1, 80000, log(1000), 400);
  (ui_drag() || ui_click()) ? slider10 = new_val;
  ui_pop();
  gfx_r = 1.0; gfx_g = 1.0; gfx_b = 1.0; gfx_a = 1;
);
strcpy(#lbl, "DELAY");  draw_label_at(col1_x, row2_y - 49);
slider10 >= 1000 ? (
  sprintf(#val, "%.2f s", slider10 / 1000);
) : (
  sprintf(#val, "%.0f ms", slider10);
);
draw_value_at(col1_x, row2_y + 39);

// FEEDBACK
ui_push_rect(col2_x - 35, row2_y - 35, 70, 70);
new_val = control_dial(slider21, -90, 15, 0, -4);
(ui_drag() || ui_click()) ? slider21 = new_val;
ui_pop();
strcpy(#lbl, "FEEDBACK");  draw_label_at(col2_x, row2_y - 49);
sprintf(#val, "%.1f dB", slider21);  draw_value_at(col2_x, row2_y + 39);

// PING PONG
ui_push_rect(col3_x - 35, row2_y - 35, 70, 70);
new_val = control_dial(slider37, 0, 100, 0, 0);
(ui_drag() || ui_click()) ? slider37 = new_val;
ui_pop();
strcpy(#lbl, "PING PONG");  draw_label_at(col3_x, row2_y - 49);
sprintf(#val, "%.0f%%", slider37);  draw_value_at(col3_x, row2_y + 39);

// ROW 3: SATURATION, LOW PASS, DELAY SYNC

// SATURATION
ui_push_rect(col1_x - 35, row3_y - 35, 70, 70);
new_val = control_dial(slider35, 1, 100, 0, 1);
(ui_drag() || ui_click()) ? slider35 = new_val;
ui_pop();
strcpy(#lbl, "SATURATION");  draw_label_at(col1_x, row3_y - 49);
sprintf(#val, "%.0f%%", slider35);  draw_value_at(col1_x, row3_y + 39);

// LOW PASS
ui_push_rect(col2_x - 35, row3_y - 35, 70, 70);
new_val = control_dial(slider30, 1000, 15000, 0, 10000);
(ui_drag() || ui_click()) ? slider30 = new_val;
ui_pop();
strcpy(#lbl, "LOW PASS");  draw_label_at(col2_x, row3_y - 49);
slider30 >= 1000 ? (
  sprintf(#val, "%.1f kHz", slider30 / 1000);
) : (
  sprintf(#val, "%.0f Hz", slider30);
);
draw_value_at(col2_x, row3_y + 39);

// DELAY SYNC selector + SYNC ON button
// Layout: selector box on left, ON button on right, centered together
sync_box_w = 80;
sync_box_h = 60;
sync_btn_w = 48;
sync_gap = 6;
sync_total_w = sync_box_w + sync_gap + sync_btn_w;
sync_box_x = col3_x - sync_total_w/2;
sync_box_y = row3_y - sync_box_h/2;
sync_btn_x = sync_box_x + sync_box_w + sync_gap;
arrow_h = 20;

// Sync selector box — dimmed when sync is off
sync_on ? (
  gfx_r = 0.16; gfx_g = 0.16; gfx_b = 0.18;
) : (
  gfx_r = 0.12; gfx_g = 0.12; gfx_b = 0.13;
);
gfx_a = 1;
gfx_rect(sync_box_x, sync_box_y, sync_box_w, sync_box_h);

gfx_r = 0.28; gfx_g = 0.28; gfx_b = 0.32; gfx_a = 1;
gfx_rect(sync_box_x, sync_box_y, sync_box_w, 1);
gfx_rect(sync_box_x, sync_box_y + sync_box_h, sync_box_w, 1);
gfx_rect(sync_box_x, sync_box_y, 1, sync_box_h);
gfx_rect(sync_box_x + sync_box_w, sync_box_y, 1, sync_box_h + 1);

// Up/down arrows only active when sync is on
sync_on ? (
  ui_push_rect(sync_box_x, sync_box_y, sync_box_w, arrow_h);
  ui_click() ? (
    slider11 = min(28, slider11 + 1);
    sliderchange(slider11);
  );
  ui_pop();
  ui_push_rect(sync_box_x, sync_box_y + sync_box_h - arrow_h, sync_box_w, arrow_h);
  ui_click() ? (
    slider11 = max(1, slider11 - 1);
    sliderchange(slider11);
  );
  ui_pop();
  gfx_r = 0.55; gfx_g = 0.55; gfx_b = 0.58;
) : (
  gfx_r = 0.30; gfx_g = 0.30; gfx_b = 0.32;
);
gfx_a = 1;
gfx_triangle(sync_box_x + sync_box_w/2, sync_box_y + 5,
             sync_box_x + sync_box_w/2 - 8, sync_box_y + 15,
             sync_box_x + sync_box_w/2 + 8, sync_box_y + 15);
gfx_triangle(sync_box_x + sync_box_w/2, sync_box_y + sync_box_h - 5,
             sync_box_x + sync_box_w/2 - 8, sync_box_y + sync_box_h - 15,
             sync_box_x + sync_box_w/2 + 8, sync_box_y + sync_box_h - 15);

// Sync value text
sync_on ? (
  gfx_r = 0.9; gfx_g = 0.2; gfx_b = 0.2;
) : (
  gfx_r = 0.35; gfx_g = 0.35; gfx_b = 0.37;
);
gfx_a = 1;
gfx_setfont(1, "Arial", 14);
sprintf(#sync_val, "%s", get_sync_name(slider11));
gfx_measurestr(#sync_val, sync_w, sync_h);
gfx_x = sync_box_x + (sync_box_w - sync_w) / 2;
gfx_y = sync_box_y + (sync_box_h - sync_h) / 2;
gfx_drawstr(#sync_val);

// SYNC ON tab-style button
ui_push_rect(sync_btn_x, sync_box_y, sync_btn_w, sync_box_h);
  sync_on ? (
    control_background_inset();
  ) : (
    control_background_enabled("none");
  );
  ui_color(255, 255, 255);
  ui_align(0.5, 0.5);
  ui_fontsize(9);
  ui_text("SYNC");
  sync_on ? control_finish_inset() : control_finish_enabled("none");
  ui_click() ? (
    slider38 = 1 - slider38;
    sync_on = slider38;
    sliderchange(slider38);
    sync_on ? (
      new_sync_time = calculate_sync_time(slider11);
      abs(new_sync_time - slider10) > 0.5 ? (
        slider10 = new_sync_time;
        target_delay_samples = min(floor(srate * 0.001 * slider10), max_delay_samples - 4);
        oslider10 = slider10;
      );
    );
  );
ui_pop();

strcpy(#lbl, "DELAY SYNC");  draw_label_at(col3_x, row3_y - 49);

); // end ui_screen
