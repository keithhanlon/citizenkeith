desc: Tycho Delay TMA-2
version: 1.0
author: citizenkeith - Claude AI
about: Advanced stereo delay with spring reverb, filters, and modulation

// ===== GENERAL SECTION =====
slider1:0<-90,15,0.1>-Input Gain (dB)
slider2:0<-90,15,0.1>-Output Gain (dB)
slider3:0.5<0,1,0.01>-Mix
slider4:-90<-90,0,0.1>-Attack Threshold (dB)
slider5:0<0,100,0.1>-Spring Reverb (%)

// ===== DELAY SECTION =====
slider10:400<0.1,6000,0.1>-Delay Time (ms)
slider11:0<0,28,1{Off,1/32,1/16T,1/32D,1/16,1/8T,1/16D,1/8,1/4T,1/8D,1/4,1/2T,1/4D,1/2,1T,1/2D,1,2T,1D,2,4T,2D,4,8T,4D,8,16T,8D,16}>-Delay Sync
slider12:0.4<0,1.5,0.01>-Feedback
slider13:0<0,2,1{Single,Ping Pong,Dual/Stereo}>-Delay Mode
slider14:0<0,1,1{Off,On}>-Tap Tempo
slider15:0<0,1,1{Off,On}>-Freeze

// ===== FILTERS SECTION =====
slider20:20<20,20000,1>-Low Cut (Hz)
slider21:20000<20,20000,1>-High Cut (Hz)

// ===== MODELING SECTION =====
slider30:0<0,3,1{No Modeling,Hard Clip,Soft Clip,Tube}>-Modeling Type
slider31:8<1,16,1>-Bit Depth
slider32:1<0.1,1,0.01>-Sample Rate Reduction
slider33:0.5<0,1,0.01>-Bitcrush Tone
slider34:0.3<0,1,0.01>-Tube Drive
slider35:0.5<0,1,0.01>-Tube Tone

// ===== MODULATION SECTION =====
slider40:0<0,10,0.01>-LFO Rate (Hz)
slider41:0<0,100,0.1>-LFO Depth (%)
slider42:0<0,5,1{Off,Sine,Triangle,Sawtooth,Square,S&H}>-LFO Wave
slider43:0<0,2,1{Delay Time,Filter Cutoff,Feedback}>-LFO Target
slider44:0<0,100,0.1>-Envelope Follower (%)
slider45:0<0,2,1{Off,Low,High}>-Env Follower Target

// ===== EFFECTS SECTION =====
slider50:0<0,10,0.01>-Tremolo Rate (Hz)
slider51:0<0,100,0.1>-Tremolo Depth (%)
slider52:0<0,10,0.01>-Phaser Rate (Hz)
slider53:0<0,100,0.1>-Phaser Depth (%)

options:gfx_hz=15 no_meter gfx_idle

@init

// Buffer setup
buffer_size = 192000;
delay_buffer_L = 0;
delay_buffer_R = buffer_size;
delay_buffer_L2 = buffer_size * 2;
delay_buffer_R2 = buffer_size * 3;

// Spring reverb buffers - 8 seconds for long decay
spring_buffer_size = floor(8.0 * srate);
spring_buffer_L = buffer_size * 4;
spring_buffer_R = spring_buffer_L + spring_buffer_size;

// Clear all buffers
memset(delay_buffer_L, 0, buffer_size);
memset(delay_buffer_R, 0, buffer_size);
memset(delay_buffer_L2, 0, buffer_size);
memset(delay_buffer_R2, 0, buffer_size);
memset(spring_buffer_L, 0, spring_buffer_size);
memset(spring_buffer_R, 0, spring_buffer_size);

// Write positions
write_pos = 0;
write_pos2 = 0;
spring_write_L = 0;
spring_write_R = 0;

// Parameters
current_delay_samples = 0;
target_delay_samples = 0;
attack_envelope = 1;

// Spring reverb delays
spring_delay1 = min(floor(0.041 * srate), spring_buffer_size - 1);
spring_delay2 = min(floor(0.063 * srate), spring_buffer_size - 1);
spring_delay3 = min(floor(0.089 * srate), spring_buffer_size - 1);
spring_delay4 = min(floor(0.127 * srate), spring_buffer_size - 1);
spring_delay5 = min(floor(0.181 * srate), spring_buffer_size - 1);
spring_delay6 = min(floor(0.251 * srate), spring_buffer_size - 1);

// Modulation
mod_phase = 0;
tremolo_phase = 0;
phaser_phase = 0;

// Advanced modulation variables
lfo_sample_hold_value = 0;
lfo_sample_hold_timer = 0;
envelope_follower_state = 0;
envelope_attack = 0.01;
envelope_release = 0.1;

// Filter modulation tracking
last_low_cut = 0;
last_high_cut = 0;

// Filter states
lpf_L.x1 = lpf_L.x2 = lpf_L.y1 = lpf_L.y2 = 0;
lpf_R.x1 = lpf_R.x2 = lpf_R.y1 = lpf_R.y2 = 0;
hpf_L.x1 = hpf_L.x2 = hpf_L.y1 = hpf_L.y2 = 0;
hpf_R.x1 = hpf_R.x2 = hpf_R.y1 = hpf_R.y2 = 0;

// Filter states for spring reverb darkening
spring_lpf_L.x1 = spring_lpf_L.x2 = spring_lpf_L.y1 = spring_lpf_L.y2 = 0;
spring_lpf_R.x1 = spring_lpf_R.x2 = spring_lpf_R.y1 = spring_lpf_R.y2 = 0;
spring_lpf2_L.x1 = spring_lpf2_L.x2 = spring_lpf2_L.y1 = spring_lpf2_L.y2 = 0;
spring_lpf2_R.x1 = spring_lpf2_R.x2 = spring_lpf2_R.y1 = spring_lpf2_R.y2 = 0;

// Initialize modeling states
sample_hold_counter = 0;
sample_hold_L = 0;
sample_hold_R = 0;
tone_state_L = 0;
tone_state_R = 0;
tube_state_L = 0;
tube_state_R = 0;

// Smoothing
smooth_coeff = exp(-2 * $pi * 20 / srate);

// Mouse variables and dropdown
mouse_knob = 0;
drag_start_y = 0;
last_mouse_cap = 0;
dropdown_open = 0;
dropdown_hover = -1;

// Level meter smoothing
input_level_smooth = 0;
delayed_level_smooth = 0;
meter_smooth = 0.95;

// Parameter smoothing function
function smooth_param(current, target) (
  current + (target - current) * (1 - smooth_coeff);
);

// Simple delay read
function delay_read(buffer, delay_samples, write_pos) (
  delay_samples = max(1, min(delay_samples, buffer_size - 1));
  read_pos = write_pos - delay_samples;
  read_pos < 0 ? read_pos += buffer_size;
  buffer[read_pos];
);

// Biquad filter functions
function bq_setlp(freq) (
  freq = max(20, min(freq, srate * 0.49));
  omega = 2 * $pi * freq / srate;
  cos_omega = cos(omega);
  sin_omega = sin(omega);
  alpha = sin_omega / (2 * 0.707);
  
  b0 = (1 - cos_omega) * 0.5;
  b1 = 1 - cos_omega;
  b2 = b0;
  a0 = 1 + alpha;
  a1 = -2 * cos_omega;
  a2 = 1 - alpha;
  
  this.b0 = b0 / a0;
  this.b1 = b1 / a0;
  this.b2 = b2 / a0;
  this.a1 = a1 / a0;
  this.a2 = a2 / a0;
);

function bq_sethp(freq) (
  freq = max(20, min(freq, srate * 0.49));
  omega = 2 * $pi * freq / srate;
  cos_omega = cos(omega);
  sin_omega = sin(omega);
  alpha = sin_omega / (2 * 0.707);
  
  b0 = (1 + cos_omega) * 0.5;
  b1 = -(1 + cos_omega);
  b2 = b0;
  a0 = 1 + alpha;
  a1 = -2 * cos_omega;
  a2 = 1 - alpha;
  
  this.b0 = b0 / a0;
  this.b1 = b1 / a0;
  this.b2 = b2 / a0;
  this.a1 = a1 / a0;
  this.a2 = a2 / a0;
);

function bq_process(input) (
  output = this.b0 * input + this.b1 * this.x1 + this.b2 * this.x2 
           - this.a1 * this.y1 - this.a2 * this.y2;
  
  this.x2 = this.x1; this.x1 = input;
  this.y2 = this.y1; this.y1 = output;
  output;
);

// Spring reverb - very long, very dark
function process_spring(input_L, input_R, amount) (
  amount > 0 ? (
    // Calculate read positions
    read1_L = spring_write_L - spring_delay1;
    read1_R = spring_write_R - spring_delay1;
    read2_L = spring_write_L - spring_delay2;
    read2_R = spring_write_R - spring_delay2;
    read3_L = spring_write_L - spring_delay3;
    read3_R = spring_write_R - spring_delay3;
    read4_L = spring_write_L - spring_delay4;
    read4_R = spring_write_R - spring_delay4;
    read5_L = spring_write_L - spring_delay5;
    read5_R = spring_write_R - spring_delay5;
    read6_L = spring_write_L - spring_delay6;
    read6_R = spring_write_R - spring_delay6;
    
    // Wrap boundaries
    read1_L < 0 ? read1_L += spring_buffer_size;
    read1_R < 0 ? read1_R += spring_buffer_size;
    read2_L < 0 ? read2_L += spring_buffer_size;
    read2_R < 0 ? read2_R += spring_buffer_size;
    read3_L < 0 ? read3_L += spring_buffer_size;
    read3_R < 0 ? read3_R += spring_buffer_size;
    read4_L < 0 ? read4_L += spring_buffer_size;
    read4_R < 0 ? read4_R += spring_buffer_size;
    read5_L < 0 ? read5_L += spring_buffer_size;
    read5_R < 0 ? read5_R += spring_buffer_size;
    read6_L < 0 ? read6_L += spring_buffer_size;
    read6_R < 0 ? read6_R += spring_buffer_size;
    
    // Read taps
    tap1_L = spring_buffer_L[read1_L];
    tap1_R = spring_buffer_R[read1_R];
    tap2_L = spring_buffer_L[read2_L];
    tap2_R = spring_buffer_R[read2_R];
    tap3_L = spring_buffer_L[read3_L];
    tap3_R = spring_buffer_R[read3_R];
    tap4_L = spring_buffer_L[read4_L];
    tap4_R = spring_buffer_R[read4_R];
    tap5_L = spring_buffer_L[read5_L];
    tap5_R = spring_buffer_R[read5_R];
    tap6_L = spring_buffer_L[read6_L];
    tap6_R = spring_buffer_R[read6_R];
    
    // Early reflections
    early_L = tap1_L * 0.4 + tap2_R * 0.35 + tap3_L * 0.25;
    early_R = tap1_R * 0.4 + tap2_L * 0.35 + tap3_R * 0.25;
    
    // Apply first stage darkening
    early_L = spring_lpf_L.bq_process(early_L);
    early_R = spring_lpf_R.bq_process(early_R);
    
    // Late reflections
    late_L = tap4_L * 0.4 + tap5_R * 0.35 + tap6_L * 0.3;
    late_R = tap4_R * 0.4 + tap5_L * 0.35 + tap6_R * 0.3;
    
    // Aggressive darkening for late reflections
    late_L = spring_lpf_L.bq_process(late_L);
    late_R = spring_lpf_R.bq_process(late_R);
    late_L = spring_lpf2_L.bq_process(late_L);
    late_R = spring_lpf2_R.bq_process(late_R);
    
    late_L *= 0.4;
    late_R *= 0.4;
    
    // Combine early and late
    spring_L = early_L * 0.5 + late_L * 0.8;
    spring_R = early_R * 0.5 + late_R * 0.8;
    
    // Final darkening
    spring_L = spring_lpf_L.bq_process(spring_L);
    spring_R = spring_lpf_R.bq_process(spring_R);
    
    spring_L *= 0.5;
    spring_R *= 0.5;
    
    // Write with high feedback
    feedback_gain = 0.82;
    spring_buffer_L[spring_write_L] = input_L + spring_L * feedback_gain;
    spring_buffer_R[spring_write_R] = input_R + spring_R * feedback_gain;
    
    spring_write_L += 1;
    spring_write_L >= spring_buffer_size ? spring_write_L = 0;
    spring_write_R += 1;
    spring_write_R >= spring_buffer_size ? spring_write_R = 0;
    
    this.left = spring_L * amount;
    this.right = spring_R * amount;
  ) : (
    this.left = 0;
    this.right = 0;
  );
);

// Tempo sync calculation
function calculate_sync_time(sync_index) local(beats, ms_per_beat) (
  ms_per_beat = 60000 / max(60, tempo);
  
  sync_index == 1 ? beats = 1/8 :
  sync_index == 2 ? beats = 1/6 :
  sync_index == 3 ? beats = 3/16 :
  sync_index == 4 ? beats = 1/4 :
  sync_index == 5 ? beats = 1/3 :
  sync_index == 6 ? beats = 3/8 :
  sync_index == 7 ? beats = 1/2 :
  sync_index == 8 ? beats = 2/3 :
  sync_index == 9 ? beats = 3/4 :
  sync_index == 10 ? beats = 1 :
  sync_index == 11 ? beats = 4/3 :
  sync_index == 12 ? beats = 1.5 :
  sync_index == 13 ? beats = 2 :
  sync_index == 14 ? beats = 8/3 :
  sync_index == 15 ? beats = 3 :
  sync_index == 16 ? beats = 4 :
  sync_index == 17 ? beats = 16/3 :
  sync_index == 18 ? beats = 6 :
  sync_index == 19 ? beats = 8 :
  sync_index == 20 ? beats = 32/3 :
  sync_index == 21 ? beats = 12 :
  sync_index == 22 ? beats = 16 :
  sync_index == 23 ? beats = 64/3 :
  sync_index == 24 ? beats = 24 :
  sync_index == 25 ? beats = 32 :
  sync_index == 26 ? beats = 128/3 :
  sync_index == 27 ? beats = 48 :
  sync_index == 28 ? beats = 64 :
  beats = 1;
  
  beats * ms_per_beat;
);

@slider

// Update delay time
(slider11 > 0) ? (
  slider10 = calculate_sync_time(slider11);
);

target_delay_samples = floor(srate * slider10 * 0.001);
target_delay_samples = max(1, min(target_delay_samples, buffer_size - 1));

// Update filters
hpf_L.bq_sethp(slider20);  // Low Cut = High Pass
hpf_R.bq_sethp(slider20);
lpf_L.bq_setlp(slider21);  // High Cut = Low Pass  
lpf_R.bq_setlp(slider21);

// Set up spring reverb darkening filters
spring_lpf_L.bq_setlp(3500);
spring_lpf_R.bq_setlp(3500);
spring_lpf2_L.bq_setlp(2000);
spring_lpf2_R.bq_setlp(2000);

@sample

// Smooth delay time changes
current_delay_samples = smooth_param(current_delay_samples, target_delay_samples);
current_delay_samples = floor(current_delay_samples);

// Input processing
input_gain = 10^(slider1/20);
in_L = spl0 * input_gain;
in_R = spl1 * input_gain;

// Attack gate
slider4 > -89 ? (
  input_level = max(abs(in_L), abs(in_R));
  attack_thresh = 10^(slider4/20);
  input_level > attack_thresh ? (
    attack_envelope = smooth_param(attack_envelope, 1);
  ) : (
    attack_envelope = smooth_param(attack_envelope, 0);
  );
  gated_L = in_L * attack_envelope;
  gated_R = in_R * attack_envelope;
) : (
  gated_L = in_L;
  gated_R = in_R;
);

// Advanced Modulation - inspired by Spaceship Delay
lfo_value = 0;
env_follower_value = 0;

// LFO Generation with multiple waveforms
slider42 > 0 && slider41 > 0 ? (
  mod_phase += slider40 / srate;
  mod_phase >= 1 ? mod_phase -= 1;
  
  // Generate different waveforms
  slider42 == 1 ? ( // Sine
    lfo_value = sin(mod_phase * 2 * $pi);
  ) : slider42 == 2 ? ( // Triangle
    lfo_value = mod_phase < 0.5 ? (4 * mod_phase - 1) : (3 - 4 * mod_phase);
  ) : slider42 == 3 ? ( // Sawtooth
    lfo_value = 2 * mod_phase - 1;
  ) : slider42 == 4 ? ( // Square
    lfo_value = mod_phase < 0.5 ? -1 : 1;
  ) : slider42 == 5 ? ( // Sample & Hold
    lfo_sample_hold_timer += 1;
    lfo_sample_hold_timer >= (srate / max(0.1, slider40)) ? (
      lfo_sample_hold_timer = 0;
      lfo_sample_hold_value = (rand(2) - 1);
    );
    lfo_value = lfo_sample_hold_value;
  );
  
  // Scale by depth
  lfo_value *= slider41 * 0.01;
);

// Envelope Follower - tracks input dynamics
slider44 > 0 ? (
  input_envelope = max(abs(in_L), abs(in_R));
  
  // Smooth envelope following with attack/release
  input_envelope > envelope_follower_state ? (
    envelope_follower_state += (input_envelope - envelope_follower_state) * envelope_attack;
  ) : (
    envelope_follower_state += (input_envelope - envelope_follower_state) * envelope_release;
  );
  
  env_follower_value = envelope_follower_state * slider44 * 0.01;
);

// Apply modulations to targets before delay processing
mod_delay_time = current_delay_samples;
mod_filter_cutoff = 1.0;
mod_feedback = slider12;

// LFO Modulation
slider43 == 0 ? ( // Delay Time
  mod_delay_time = current_delay_samples * (1 + lfo_value * 0.1);
) : slider43 == 1 ? ( // Filter Cutoff  
  mod_filter_cutoff = 1 + lfo_value * 0.5;
) : slider43 == 2 ? ( // Feedback
  mod_feedback = slider12 * (1 + lfo_value * 0.3);
);

// Envelope Follower Modulation
slider45 == 1 ? ( // Low frequencies
  mod_filter_cutoff *= (1 - env_follower_value * 0.5);
) : slider45 == 2 ? ( // High frequencies  
  mod_filter_cutoff *= (1 + env_follower_value * 0.5);
);

// Safety limiter to prevent REAPER auto-muting
function safety_limiter(input) (
  input_level = abs(input);
  input_level > 0.95 ? (
    // Soft compression above 95% to prevent auto-mute
    overage = (input_level - 0.95) / 0.05;
    compression_ratio = 1 / (1 + overage * 3);
    input * (0.95 + (input_level - 0.95) * compression_ratio) / input_level;
  ) : (
    input;
  );
);
mod_delay_time = max(1, min(buffer_size - 1, mod_delay_time));
mod_filter_cutoff = max(0.1, min(2.0, mod_filter_cutoff));
mod_feedback = max(0, min(1.5, mod_feedback));

// Delay processing with modulated parameters
delayed_L = 0;
delayed_R = 0;

current_delay_samples >= 1 ? (
  // Use modulated delay time and feedback
  actual_delay = mod_delay_time;
  actual_feedback = mod_feedback;
  
  slider13 == 0 ? ( // Single mode
    delayed_L = delay_read(delay_buffer_L, actual_delay, write_pos);
    delayed_R = delay_read(delay_buffer_R, actual_delay, write_pos);
    
    slider15 ? ( // Freeze mode - infinite loop
      delay_buffer_L[write_pos] = safety_limiter(delayed_L);
      delay_buffer_R[write_pos] = safety_limiter(delayed_R);
    ) : ( // Normal mode
      feedback_L = gated_L + delayed_L * actual_feedback;
      feedback_R = gated_R + delayed_R * actual_feedback;
      delay_buffer_L[write_pos] = safety_limiter(feedback_L);
      delay_buffer_R[write_pos] = safety_limiter(feedback_R);
    );
    
  ) : slider13 == 1 ? ( // Ping pong mode
    temp_L = delay_read(delay_buffer_L, actual_delay, write_pos);
    temp_R = delay_read(delay_buffer_R, actual_delay, write_pos);
    
    delayed_L = temp_L;
    delayed_R = temp_R;
    
    slider15 ? ( // Freeze mode
      delay_buffer_L[write_pos] = safety_limiter(temp_R);
      delay_buffer_R[write_pos] = safety_limiter(temp_L);
    ) : ( // Normal mode
      feedback_L = gated_L + temp_R * actual_feedback;
      feedback_R = gated_R + temp_L * actual_feedback;
      delay_buffer_L[write_pos] = safety_limiter(feedback_L);
      delay_buffer_R[write_pos] = safety_limiter(feedback_R);
    );
    
  ) : ( // Dual/Stereo mode
    delayed_L = delay_read(delay_buffer_L, actual_delay, write_pos);
    delayed_R = delay_read(delay_buffer_R, actual_delay * 1.1, write_pos2);
    
    slider15 ? ( // Freeze mode
      delay_buffer_L[write_pos] = safety_limiter(delayed_L);
      delay_buffer_R[write_pos2] = safety_limiter(delayed_R);
    ) : ( // Normal mode
      feedback_L = gated_L + delayed_L * actual_feedback;
      feedback_R = gated_R + delayed_R * actual_feedback;
      delay_buffer_L[write_pos] = safety_limiter(feedback_L);
      delay_buffer_R[write_pos2] = safety_limiter(feedback_R);
    );
  );
);

// Update write positions
write_pos += 1;
write_pos >= buffer_size ? write_pos = 0;

slider13 == 2 ? (
  write_pos2 += 1;
  write_pos2 >= buffer_size ? write_pos2 = 0;
);

// Filtering with modulated cutoff frequencies
mod_low_cut = slider20 * mod_filter_cutoff;
mod_high_cut = slider21 * mod_filter_cutoff;

// Constrain to valid ranges
mod_low_cut = max(20, min(20000, mod_low_cut));
mod_high_cut = max(20, min(20000, mod_high_cut));

// Update filter coefficients if cutoff changed
abs(mod_low_cut - last_low_cut) > 1 || abs(mod_high_cut - last_high_cut) > 1 ? (
  hpf_L.bq_sethp(mod_low_cut);
  hpf_R.bq_sethp(mod_low_cut);
  lpf_L.bq_setlp(mod_high_cut);
  lpf_R.bq_setlp(mod_high_cut);
  last_low_cut = mod_low_cut;
  last_high_cut = mod_high_cut;
);

delayed_L = lpf_L.bq_process(delayed_L);
delayed_R = lpf_R.bq_process(delayed_R);
delayed_L = hpf_L.bq_process(delayed_L);
delayed_R = hpf_R.bq_process(delayed_R);

// Modeling
slider30 > 0 ? (
  slider30 == 1 ? ( // Hard Clip
    delayed_L > 0.8 ? delayed_L = 0.8 : delayed_L < -0.8 ? delayed_L = -0.8;
    delayed_R > 0.8 ? delayed_R = 0.8 : delayed_R < -0.8 ? delayed_R = -0.8;
    
  ) : slider30 == 2 ? ( // Soft Clip
    delayed_L = delayed_L / (1 + abs(delayed_L * 0.7));
    delayed_R = delayed_R / (1 + abs(delayed_R * 0.7));
    
  ) : slider30 == 3 ? ( // Tube
    drive = slider34 * 8 + 1;
    tone = slider35;
    
    // Apply heavy drive
    delayed_L *= drive;
    delayed_R *= drive;
    
    // Tube saturation
    delayed_L = delayed_L > 0 ? 
      delayed_L / (1 + delayed_L * 2.5) :
      delayed_L / (1 - delayed_L * 1.8);
    delayed_R = delayed_R > 0 ? 
      delayed_R / (1 + delayed_R * 2.5) :
      delayed_R / (1 - delayed_R * 1.8);
    
    // Add harmonics
    delayed_L += delayed_L * delayed_L * delayed_L * 0.1;
    delayed_R += delayed_R * delayed_R * delayed_R * 0.1;
    
    // Scale back
    delayed_L /= (drive * 0.8);
    delayed_R /= (drive * 0.8);
    
    // Tube tone control
    tone < 0.5 ? (
      cutoff = 1000 + tone * 8000;
      tube_smooth = exp(-2 * $pi * cutoff / srate);
      tube_state_L += (delayed_L - tube_state_L) * (1 - tube_smooth);
      tube_state_R += (delayed_R - tube_state_R) * (1 - tube_smooth);
      delayed_L = tube_state_L;
      delayed_R = tube_state_R;
    ) : (
      emphasis = (tone - 0.5) * 2;
      high_freq = delayed_L - tube_state_L;
      delayed_L = delayed_L + high_freq * emphasis * 0.3;
      high_freq = delayed_R - tube_state_R;
      delayed_R = delayed_R + high_freq * emphasis * 0.3;
      tube_state_L = delayed_L;
      tube_state_R = delayed_R;
    );
  );
);

// Spring reverb - apply to input and add to delayed
spring_L = 0;
spring_R = 0;

slider5 > 0 ? (
  spring_amount = slider5 * 0.01;
  spring.process_spring(gated_L, gated_R, spring_amount);
  spring_L = spring.left;
  spring_R = spring.right;
);

delayed_L += spring_L;
delayed_R += spring_R;

// Effects
slider51 > 0 ? (
  tremolo_phase += slider50 / srate;
  tremolo_phase >= 1 ? tremolo_phase -= 1;
  
  trem_lfo = sin(tremolo_phase * 2 * $pi);
  trem_gain = 1 - (slider51 * 0.01 * (1 - trem_lfo) * 0.5);
  delayed_L *= trem_gain;
  delayed_R *= trem_gain;
);

// Update level meters (smoothed for stability)
input_level_current = max(abs(in_L), abs(in_R));
delayed_level_current = max(abs(delayed_L), abs(delayed_R));

// Standard level smoothing
input_level_current = min(1.0, input_level_current);
delayed_level_current = min(1.0, delayed_level_current);
meter_smooth = 0.95;

// Apply smoothing
input_level_smooth = input_level_smooth * meter_smooth + input_level_current * (1 - meter_smooth);
delayed_level_smooth = delayed_level_smooth * meter_smooth + delayed_level_current * (1 - meter_smooth);

// Final safety clamp for GUI
input_level_smooth = max(0, min(1, input_level_smooth));
delayed_level_smooth = max(0, min(1, delayed_level_smooth));

// Final mix and output
dry_gain = 1 - slider3;
wet_gain = slider3;
output_gain = 10^(slider2/20);

dry_with_spring_L = spl0 + spring_L;
dry_with_spring_R = spl1 + spring_R;

spl0 = (dry_with_spring_L * dry_gain + delayed_L * wet_gain) * output_gain;
spl1 = (dry_with_spring_R * dry_gain + delayed_R * wet_gain) * output_gain;

@gfx 900 600

// Simple anti-flashing: if slider30 is out of range, reset it
slider30 > 3 ? slider30 = 0;

// Calculate scale factor
base_width = 900;
base_height = 600;
scale_x = gfx_w / base_width;
scale_y = gfx_h / base_height;
scale = min(scale_x, scale_y);
scale = max(0.5, min(scale, 3.0));

// Clear background once
gfx_r = 0.85; gfx_g = 0.85; gfx_b = 0.85;
gfx_rect(0, 0, gfx_w, gfx_h);

// Title panel
gfx_r = 0.72; gfx_g = 0.72; gfx_b = 0.72;
gfx_rect(floor(20 * scale), floor(10 * scale), floor(gfx_w - 40 * scale), floor(50 * scale));

// Control panel
gfx_rect(floor(20 * scale), floor(80 * scale), floor(gfx_w - 40 * scale), floor(gfx_h - 120 * scale));

// Set up fonts once - using different slots for different sizes
gfx_setfont(1, "Arial", max(8, floor(18 * scale)), 'b');  // Title font
gfx_setfont(2, "Arial", max(8, floor(12 * scale)));        // Subtitle font
gfx_setfont(3, "Arial", max(8, floor(10 * scale)), 'b');   // Header font
gfx_setfont(4, "Arial", max(6, floor(10 * scale)));        // Label font
gfx_setfont(5, "Arial", max(8, floor(10 * scale)));        // UI text font

// Title text
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_setfont(1);
gfx_x = floor(40 * scale); gfx_y = floor(22 * scale);
gfx_drawstr("Tycho Delay TMA-2");

gfx_setfont(2);
gfx_x = floor(40 * scale); gfx_y = floor(42 * scale);
gfx_drawstr("Advanced Stereo Delay with Spring Reverb & Modulation");

// Red accent
gfx_r = 0.55; gfx_g = 0; gfx_b = 0;
gfx_rect(floor(gfx_w - 80 * scale), floor(20 * scale), floor(40 * scale), floor(4 * scale));

// Calculate centered column positions
available_width = gfx_w - 60 * scale;
column_width = available_width / 6;
start_x = 30 * scale;

col1_x = floor(start_x + column_width * 0.5);   // General
col2_x = floor(start_x + column_width * 1.5);   // Delay  
col3_x = floor(start_x + column_width * 2.5);   // Filters
col4_x = floor(start_x + column_width * 3.5);   // Modeling
col5_x = floor(start_x + column_width * 4.5);   // Modulation
col6_x = floor(start_x + column_width * 5.5);   // Effects

start_y = floor(140 * scale);

// Column headers
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_setfont(3);

gfx_measurestr("GENERAL", label_w, label_h);
gfx_x = col1_x - label_w/2; gfx_y = floor(100 * scale); gfx_drawstr("GENERAL");

gfx_measurestr("DELAY", label_w, label_h);
gfx_x = col2_x - label_w/2; gfx_y = floor(100 * scale); gfx_drawstr("DELAY");

gfx_measurestr("FILTERS", label_w, label_h);
gfx_x = col3_x - label_w/2; gfx_y = floor(100 * scale); gfx_drawstr("FILTERS");

gfx_measurestr("MODELING", label_w, label_h);
gfx_x = col4_x - label_w/2; gfx_y = floor(100 * scale); gfx_drawstr("MODELING");

gfx_measurestr("MODULATION", label_w, label_h);
gfx_x = col5_x - label_w/2; gfx_y = floor(100 * scale); gfx_drawstr("MODULATION");

gfx_measurestr("EFFECTS", label_w, label_h);
gfx_x = col6_x - label_w/2; gfx_y = floor(100 * scale); gfx_drawstr("EFFECTS");

// Draw knob function
function draw_knob(x, y, value, min_val, max_val, label) local(norm_val, angle, ind_x, ind_y, knob_radius) (
  knob_radius = floor(18 * scale);
  norm_val = (value - min_val) / (max_val - min_val);
  norm_val = max(0, min(1, norm_val));
  angle = -2.356 + norm_val * 4.712;
  
  // Black knob circle
  gfx_r = 0.125; gfx_g = 0.125; gfx_b = 0.125;
  gfx_circle(x, y, knob_radius, 1);
  
  // White indicator line
  ind_x = x + sin(angle) * (knob_radius - floor(3 * scale));
  ind_y = y - cos(angle) * (knob_radius - floor(3 * scale));
  gfx_r = 1; gfx_g = 1; gfx_b = 1;
  gfx_line(x, y, ind_x, ind_y, max(1, floor(2 * scale)));
  
  // Label
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  gfx_setfont(4);
  gfx_measurestr(label, label_w, label_h);
  gfx_x = x - label_w/2; gfx_y = y + knob_radius + floor(5 * scale);
  gfx_drawstr(label);
);

// Draw switch function
function draw_switch(x, y, state, label) local(switch_w, switch_h) (
  switch_w = floor(30 * scale);
  switch_h = floor(16 * scale);
  
  gfx_r = 0.125; gfx_g = 0.125; gfx_b = 0.125;
  gfx_rect(x - switch_w/2, y - switch_h/2, switch_w, switch_h);
  state ? (gfx_r = 0.55; gfx_g = 0; gfx_b = 0;) : (gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.25;);
  gfx_rect(x + (state ? floor(2 * scale) : floor(-13 * scale)), y - floor(6 * scale), floor(11 * scale), floor(12 * scale));
  
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  gfx_setfont(4);
  gfx_measurestr(label, label_w, label_h);
  gfx_x = x - label_w/2; gfx_y = y + floor(15 * scale);
  gfx_drawstr(label);
);

// Draw all knobs
draw_knob(col1_x, start_y, slider1, -90, 15, "INPUT");
draw_knob(col1_x, start_y + floor(70 * scale), slider2, -90, 15, "OUTPUT");
draw_knob(col1_x, start_y + floor(140 * scale), slider3 * 100, 0, 100, "MIX");
draw_knob(col1_x, start_y + floor(210 * scale), slider4, -90, 0, "ATTACK");
draw_knob(col1_x, start_y + floor(280 * scale), slider5, 0, 100, "SPRING");

draw_knob(col2_x, start_y, slider10, 0.1, 6000, "TIME");
draw_knob(col2_x, start_y + floor(70 * scale), slider12 * 100, 0, 150, "FEEDBACK");
draw_switch(col2_x, start_y + floor(140 * scale), slider11 > 0, "SYNC");
draw_switch(col2_x, start_y + floor(180 * scale), slider15, "FREEZE");

draw_knob(col3_x, start_y, slider20, 20, 20000, "LOW CUT");
draw_knob(col3_x, start_y + floor(70 * scale), slider21, 20, 20000, "HIGH CUT");

draw_knob(col5_x, start_y, slider40, 0, 10, "LFO RATE");
draw_knob(col5_x, start_y + floor(60 * scale), slider41, 0, 100, "LFO DEPTH");

// LFO Wave dropdown
lfo_wave_dropdown_y = start_y + floor(120 * scale);
lfo_wave_dropdown_w = floor(80 * scale);
lfo_wave_dropdown_h = floor(16 * scale);
lfo_wave_dropdown_x = col5_x - lfo_wave_dropdown_w/2;

gfx_r = 0.2; gfx_g = 0.2; gfx_b = 0.2;
gfx_rect(lfo_wave_dropdown_x, lfo_wave_dropdown_y, lfo_wave_dropdown_w, lfo_wave_dropdown_h);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_setfont(5);
wave_text = "";
slider42 == 0 ? wave_text = "Off";
slider42 == 1 ? wave_text = "Sine";
slider42 == 2 ? wave_text = "Triangle";
slider42 == 3 ? wave_text = "Sawtooth";
slider42 == 4 ? wave_text = "Square";
slider42 == 5 ? wave_text = "S&H";

gfx_measurestr(wave_text, text_w, text_h);
gfx_x = lfo_wave_dropdown_x + 3 * scale;
gfx_y = lfo_wave_dropdown_y + (lfo_wave_dropdown_h - text_h)/2;
gfx_drawstr(wave_text);

// LFO Target dropdown
lfo_target_dropdown_y = start_y + floor(150 * scale);
lfo_target_dropdown_w = floor(80 * scale);
lfo_target_dropdown_h = floor(16 * scale);
lfo_target_dropdown_x = col5_x - lfo_target_dropdown_w/2;

gfx_r = 0.2; gfx_g = 0.2; gfx_b = 0.2;
gfx_rect(lfo_target_dropdown_x, lfo_target_dropdown_y, lfo_target_dropdown_w, lfo_target_dropdown_h);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
target_text = "";
slider43 == 0 ? target_text = "Delay Time";
slider43 == 1 ? target_text = "Filter Cut";
slider43 == 2 ? target_text = "Feedback";

gfx_measurestr(target_text, text_w, text_h);
gfx_x = lfo_target_dropdown_x + 3 * scale;
gfx_y = lfo_target_dropdown_y + (lfo_target_dropdown_h - text_h)/2;
gfx_drawstr(target_text);

draw_knob(col5_x, start_y + floor(200 * scale), slider44, 0, 100, "ENV FOLLOW");

// Env Target dropdown
env_target_dropdown_y = start_y + floor(260 * scale);
env_target_dropdown_w = floor(80 * scale);
env_target_dropdown_h = floor(16 * scale);
env_target_dropdown_x = col5_x - env_target_dropdown_w/2;

gfx_r = 0.2; gfx_g = 0.2; gfx_b = 0.2;
gfx_rect(env_target_dropdown_x, env_target_dropdown_y, env_target_dropdown_w, env_target_dropdown_h);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
env_text = "";
slider45 == 0 ? env_text = "Off";
slider45 == 1 ? env_text = "Low Freq";
slider45 == 2 ? env_text = "High Freq";

gfx_measurestr(env_text, text_w, text_h);
gfx_x = env_target_dropdown_x + 3 * scale;
gfx_y = env_target_dropdown_y + (env_target_dropdown_h - text_h)/2;
gfx_drawstr(env_text);

draw_knob(col6_x, start_y, slider50, 0, 10, "TREM RATE");
draw_knob(col6_x, start_y + floor(70 * scale), slider51, 0, 100, "TREM DEPTH");

// Column 4: Modeling dropdown (just the main button for now - dropdown drawn later)
dropdown_width = floor(100 * scale);
dropdown_height = floor(20 * scale);
dropdown_x = col4_x - dropdown_width/2;
dropdown_y = start_y;

// Main dropdown box
gfx_r = 0.2; gfx_g = 0.2; gfx_b = 0.2;
gfx_rect(dropdown_x, dropdown_y, dropdown_width, dropdown_height);

// Current selection text
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_setfont(5);
modeling_text = "";
slider30 == 0 ? modeling_text = "No Modeling";
slider30 == 1 ? modeling_text = "Hard Clip";
slider30 == 2 ? modeling_text = "Soft Clip";
slider30 == 3 ? modeling_text = "Tube";

gfx_measurestr(modeling_text, text_w, text_h);
gfx_x = dropdown_x + floor(5 * scale);
gfx_y = dropdown_y + (dropdown_height - text_h)/2;
gfx_drawstr(modeling_text);

// Dropdown arrow
arrow_x = dropdown_x + dropdown_width - floor(12 * scale);
arrow_y = dropdown_y + dropdown_height/2;
gfx_r = 0.8; gfx_g = 0.8; gfx_b = 0.8;
gfx_line(arrow_x, arrow_y - floor(3 * scale), arrow_x + floor(4 * scale), arrow_y + floor(3 * scale), 1);
gfx_line(arrow_x + floor(8 * scale), arrow_y - floor(3 * scale), arrow_x + floor(4 * scale), arrow_y + floor(3 * scale), 1);

// Show modeling knobs based on selection
slider30 == 3 ? ( // Tube controls
  draw_knob(col4_x, start_y + floor(50 * scale), slider34 * 100, 0, 100, "DRIVE");
  draw_knob(col4_x, start_y + floor(120 * scale), slider35 * 100, 0, 100, "TONE");
);

// Level meters - clear area first then draw with robust bounds checking
meter_y = floor(gfx_h - 40 * scale);
meter_x = floor(100 * scale);
meter_width = floor(250 * scale);
meter_height = floor(8 * scale);

// Clear meter area
gfx_r = 0.85; gfx_g = 0.85; gfx_b = 0.85;
gfx_rect(floor(30 * scale), meter_y - floor(5 * scale), meter_width + meter_x, floor(35 * scale));

// Redraw meter background
gfx_r = 0.72; gfx_g = 0.72; gfx_b = 0.72;
gfx_rect(floor(30 * scale), meter_y - floor(5 * scale), meter_width + meter_x, floor(35 * scale));

gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_setfont(4);
gfx_x = floor(30 * scale); gfx_y = meter_y - floor(2 * scale);
gfx_drawstr("Input:");

// Robust meter drawing with strict bounds
input_meter_width = floor(max(0, min(meter_width, input_level_smooth * meter_width)));
input_meter_width > 0 ? (
  gfx_r = 0.2; gfx_g = 0.8; gfx_b = 0.2;
  gfx_rect(meter_x, meter_y, input_meter_width, meter_height);
);

gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_x = floor(30 * scale); gfx_y = meter_y + floor(13 * scale);
gfx_drawstr("Delayed:");

delayed_meter_width = floor(max(0, min(meter_width, delayed_level_smooth * meter_width)));
delayed_meter_width > 0 ? (
  gfx_r = 0.55; gfx_g = 0; gfx_b = 0;
  gfx_rect(meter_x, meter_y + floor(15 * scale), delayed_meter_width, meter_height);
);

// Mouse interaction
mouse_cap & 1 && !(last_mouse_cap & 1) ? (
  // Dropdown interaction - highest priority
  mouse_x >= dropdown_x && mouse_x <= dropdown_x + dropdown_width &&
  mouse_y >= dropdown_y && mouse_y <= dropdown_y + dropdown_height ? (
    dropdown_open = !dropdown_open;
  ) : dropdown_open && mouse_x >= dropdown_x && mouse_x <= dropdown_x + dropdown_width &&
  mouse_y >= dropdown_y + dropdown_height && mouse_y <= dropdown_y + dropdown_height + 4 * dropdown_height ? (
    option_index = floor((mouse_y - dropdown_y - dropdown_height) / dropdown_height);
    option_index >= 0 && option_index < 4 ? (
      slider30 = option_index;
      sliderchange(30);
      dropdown_open = 0;
    );
  ) : (
    dropdown_open = 0;
  );

  // Knob clicks - check all knobs
  (mouse_x - col1_x)^2 + (mouse_y - start_y)^2 < (20 * scale)^2 ? (mouse_knob = 1; drag_start_y = mouse_y;);
  (mouse_x - col1_x)^2 + (mouse_y - (start_y + floor(70 * scale)))^2 < (20 * scale)^2 ? (mouse_knob = 2; drag_start_y = mouse_y;);
  (mouse_x - col1_x)^2 + (mouse_y - (start_y + floor(140 * scale)))^2 < (20 * scale)^2 ? (mouse_knob = 3; drag_start_y = mouse_y;);
  (mouse_x - col1_x)^2 + (mouse_y - (start_y + floor(210 * scale)))^2 < (20 * scale)^2 ? (mouse_knob = 4; drag_start_y = mouse_y;);
  (mouse_x - col1_x)^2 + (mouse_y - (start_y + floor(280 * scale)))^2 < (20 * scale)^2 ? (mouse_knob = 5; drag_start_y = mouse_y;);
  
  (mouse_x - col2_x)^2 + (mouse_y - start_y)^2 < (20 * scale)^2 ? (mouse_knob = 10; drag_start_y = mouse_y;);
  (mouse_x - col2_x)^2 + (mouse_y - (start_y + floor(70 * scale)))^2 < (20 * scale)^2 ? (mouse_knob = 12; drag_start_y = mouse_y;);
  
  (mouse_x - col3_x)^2 + (mouse_y - start_y)^2 < (20 * scale)^2 ? (mouse_knob = 20; drag_start_y = mouse_y;);
  (mouse_x - col3_x)^2 + (mouse_y - (start_y + floor(70 * scale)))^2 < (20 * scale)^2 ? (mouse_knob = 21; drag_start_y = mouse_y;);
  
  // Modeling knobs
  slider30 == 3 ? (
    (mouse_x - col4_x)^2 + (mouse_y - (start_y + floor(50 * scale)))^2 < (20 * scale)^2 ? (mouse_knob = 34; drag_start_y = mouse_y;);
    (mouse_x - col4_x)^2 + (mouse_y - (start_y + floor(120 * scale)))^2 < (20 * scale)^2 ? (mouse_knob = 35; drag_start_y = mouse_y;);
  );
  
  // Modulation knobs - make sure these work
  (mouse_x - col5_x)^2 + (mouse_y - start_y)^2 < (20 * scale)^2 ? (mouse_knob = 40; drag_start_y = mouse_y;);
  (mouse_x - col5_x)^2 + (mouse_y - (start_y + floor(60 * scale)))^2 < (20 * scale)^2 ? (mouse_knob = 41; drag_start_y = mouse_y;);
  (mouse_x - col5_x)^2 + (mouse_y - (start_y + floor(200 * scale)))^2 < (20 * scale)^2 ? (mouse_knob = 44; drag_start_y = mouse_y;);
  
  (mouse_x - col6_x)^2 + (mouse_y - start_y)^2 < (20 * scale)^2 ? (mouse_knob = 50; drag_start_y = mouse_y;);
  (mouse_x - col6_x)^2 + (mouse_y - (start_y + floor(70 * scale)))^2 < (20 * scale)^2 ? (mouse_knob = 51; drag_start_y = mouse_y;);

  // Dropdown clicks - check if NOT on knobs first
  !(mouse_knob > 0) ? (
    // LFO Wave dropdown
    mouse_x >= lfo_wave_dropdown_x && mouse_x <= lfo_wave_dropdown_x + lfo_wave_dropdown_w &&
    mouse_y >= lfo_wave_dropdown_y && mouse_y <= lfo_wave_dropdown_y + lfo_wave_dropdown_h ? (
      slider42 += 1;
      slider42 > 5 ? slider42 = 0;
      sliderchange(42);
    );
    
    // LFO Target dropdown 
    mouse_x >= lfo_target_dropdown_x && mouse_x <= lfo_target_dropdown_x + lfo_target_dropdown_w &&
    mouse_y >= lfo_target_dropdown_y && mouse_y <= lfo_target_dropdown_y + lfo_target_dropdown_h ? (
      slider43 += 1; 
      slider43 > 2 ? slider43 = 0;
      sliderchange(43);
    );
    
    // Env Target dropdown
    mouse_x >= env_target_dropdown_x && mouse_x <= env_target_dropdown_x + env_target_dropdown_w &&
    mouse_y >= env_target_dropdown_y && mouse_y <= env_target_dropdown_y + env_target_dropdown_h ? (
      slider45 += 1;
      slider45 > 2 ? slider45 = 0; 
      sliderchange(45);
    );
    
    // Delay switches
    abs(mouse_x - col2_x) < 20 * scale && abs(mouse_y - (start_y + floor(140 * scale))) < 10 * scale ? (
      slider11 = slider11 > 0 ? 0 : 10; sliderchange(11);
    );
    abs(mouse_x - col2_x) < 20 * scale && abs(mouse_y - (start_y + floor(180 * scale))) < 10 * scale ? (
      slider15 = !slider15; sliderchange(15);
    );
  );
);

// Track dropdown hover
dropdown_open ? (
  mouse_x >= dropdown_x && mouse_x <= dropdown_x + dropdown_width &&
  mouse_y >= dropdown_y + dropdown_height && mouse_y <= dropdown_y + dropdown_height + 4 * dropdown_height ? (
    dropdown_hover = floor((mouse_y - dropdown_y - dropdown_height) / dropdown_height);
  ) : (
    dropdown_hover = -1;
  );
);

// Knob dragging
mouse_cap & 1 && mouse_knob > 0 ? (
  mouse_dy = mouse_y - drag_start_y;
  drag_start_y = mouse_y;
  
  mouse_knob == 1 ? (slider1 = max(-90, min(15, slider1 - mouse_dy * 0.5)); sliderchange(1););
  mouse_knob == 2 ? (slider2 = max(-90, min(15, slider2 - mouse_dy * 0.5)); sliderchange(2););
  mouse_knob == 3 ? (slider3 = max(0, min(1, slider3 - mouse_dy * 0.005)); sliderchange(3););
  mouse_knob == 4 ? (slider4 = max(-90, min(0, slider4 - mouse_dy * 0.5)); sliderchange(4););
  mouse_knob == 5 ? (slider5 = max(0, min(100, slider5 - mouse_dy * 0.5)); sliderchange(5););
  
  mouse_knob == 10 ? (slider10 = max(0.1, min(6000, slider10 - mouse_dy * 10)); sliderchange(10););
  mouse_knob == 12 ? (slider12 = max(0, min(1.5, slider12 - mouse_dy * 0.005)); sliderchange(12););
  
  mouse_knob == 20 ? (slider20 = max(20, min(20000, slider20 - mouse_dy * 100)); sliderchange(20););
  mouse_knob == 21 ? (slider21 = max(20, min(20000, slider21 - mouse_dy * 100)); sliderchange(21););
  
  mouse_knob == 31 ? (slider31 = max(1, min(16, slider31 - mouse_dy * 0.1)); sliderchange(31););
  mouse_knob == 32 ? (slider32 = max(0.1, min(1, slider32 - mouse_dy * 0.005)); sliderchange(32););
  mouse_knob == 33 ? (slider33 = max(0, min(1, slider33 - mouse_dy * 0.005)); sliderchange(33););
  mouse_knob == 34 ? (slider34 = max(0, min(1, slider34 - mouse_dy * 0.005)); sliderchange(34););
  mouse_knob == 35 ? (slider35 = max(0, min(1, slider35 - mouse_dy * 0.005)); sliderchange(35););
  
  mouse_knob == 40 ? (slider40 = max(0, min(10, slider40 - mouse_dy * 0.05)); sliderchange(40););
  mouse_knob == 41 ? (slider41 = max(0, min(100, slider41 - mouse_dy * 0.5)); sliderchange(41););
  mouse_knob == 44 ? (slider44 = max(0, min(100, slider44 - mouse_dy * 0.5)); sliderchange(44););
  
  mouse_knob == 50 ? (slider50 = max(0, min(10, slider50 - mouse_dy * 0.05)); sliderchange(50););
  mouse_knob == 51 ? (slider51 = max(0, min(100, slider51 - mouse_dy * 0.5)); sliderchange(51););
) : (
  mouse_knob = 0;
);

last_mouse_cap = mouse_cap;

// Draw dropdown list LAST so it appears on top of everything
dropdown_open ? (
  list_height = 4 * dropdown_height;
  gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.15;
  gfx_rect(dropdown_x, dropdown_y + dropdown_height, dropdown_width, list_height);
  
  gfx_setfont(5);
  i = 0;
  loop(4,
    option_y = dropdown_y + dropdown_height + i * dropdown_height;
    
    // Highlight hovered option
    dropdown_hover == i ? (
      gfx_r = 0.55; gfx_g = 0; gfx_b = 0;
      gfx_rect(dropdown_x, option_y, dropdown_width, dropdown_height);
    );
    
    // Option text
    i == slider30 ? (gfx_r = 0.9; gfx_g = 0.7; gfx_b = 0.1;) : (gfx_r = 0.9; gfx_g = 0.9; gfx_b = 0.9;);
    gfx_x = dropdown_x + floor(5 * scale);
    gfx_y = option_y + (dropdown_height - text_h)/2;
    
    i == 0 ? gfx_drawstr("No Modeling");
    i == 1 ? gfx_drawstr("Hard Clip");
    i == 2 ? gfx_drawstr("Soft Clip");
    i == 3 ? gfx_drawstr("Tube");
    
    i += 1;
  );
);