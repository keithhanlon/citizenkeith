desc: Tycho Delay TMA-2
version: 1.5
author: citizenkeith - Claude AI
about: Advanced stereo delay with spring reverb, filters, and modulation

// ===== GENERAL SECTION =====
slider1:0<-90,15,0.1>-Input Gain (dB)
slider2:0<-90,15,0.1>-Output Gain (dB)
slider3:0.5<0,1,0.01>-Mix
slider4:-90<-90,0,0.1>-Attack Threshold (dB)
slider5:0<0,100,0.1>-Spring Reverb (%)

// ===== DELAY SECTION =====
slider10:400<10,6000,0.1>-Delay Time (ms)
slider11:0<0,28,1{Off,1/32,1/16T,1/32D,1/16,1/8T,1/16D,1/8,1/4T,1/8D,1/4,1/2T,1/4D,1/2,1T,1/2D,1,2T,1D,2,4T,2D,4,8T,4D,8,16T,8D,16}>-Delay Sync
slider12:0.4<0,1.5,0.01>-Feedback
slider13:0<0,2,1{Single,Ping Pong,Dual/Stereo}>-Delay Mode
slider14:0<0,1,1{Off,On}>-Tap Tempo
slider15:0<0,1,1{Off,On}>-Freeze
slider16:400<10,6000,0.1>-Delay Left (ms)
slider17:440<10,6000,0.1>-Delay Right (ms)
slider18:0<0,1.5,0.01>-Cross Feedback

// ===== FILTERS SECTION =====
slider20:20<20,20000,1>-Low Cut (Hz)
slider21:20000<20,20000,1>-High Cut (Hz)

// ===== MODELING SECTION =====
slider30:0<0,3,1{No Modeling,Hard Clip,Soft Clip,Tube}>-Modeling Type
slider31:8<1,16,1>-Bit Depth
slider32:1<0.1,1,0.01>-Sample Rate Reduction
slider33:0.5<0,1,0.01>-Bitcrush Tone
slider34:0.3<0,1,0.01>-Tube Drive
slider35:0.5<0,1,0.01>-Tube Tone

// ===== MODULATION SECTION =====
slider40:0<0,10,0.01>-LFO Rate (Hz)
slider41:0<0,100,0.1>-LFO Depth (%)
slider42:0<0,5,1{Off,Sine,Triangle,Sawtooth,Square,S&H}>-LFO Wave
slider43:0<0,2,1{Delay Time,Filter Cutoff,Feedback}>-LFO Target
slider44:0<0,100,0.1>-Envelope Follower (%)
slider45:0<0,2,1{Off,Low,High}>-Env Follower Target

// ===== EFFECTS SECTION =====
slider50:0<0,10,0.01>-Tremolo Rate (Hz)
slider51:0<0,100,0.1>-Tremolo Depth (%)
slider52:0<0,10,0.01>-Phaser Rate (Hz)
slider53:0<0,100,0.1>-Phaser Depth (%)

options:gfx_hz=15 no_meter gfx_idle

@init

// Buffer setup
buffer_size = 192000;
delay_buffer_L = 0;
delay_buffer_R = buffer_size;
delay_buffer_L2 = buffer_size * 2;
delay_buffer_R2 = buffer_size * 3;

// Spring reverb buffers - 4 seconds for reasonable memory usage
spring_buffer_size = floor(4.0 * srate);
spring_buffer_L = buffer_size * 4;
spring_buffer_R = spring_buffer_L + spring_buffer_size;

// Clear all buffers
memset(delay_buffer_L, 0, buffer_size);
memset(delay_buffer_R, 0, buffer_size);
memset(delay_buffer_L2, 0, buffer_size);
memset(delay_buffer_R2, 0, buffer_size);
memset(spring_buffer_L, 0, spring_buffer_size);
memset(spring_buffer_R, 0, spring_buffer_size);

// Write positions
write_pos = 0;
write_pos2 = 0;
spring_write_L = 0;
spring_write_R = 0;

// Parameters
current_delay_samples = 0;
target_delay_samples = 0;
current_delay_samples_L = 0;
current_delay_samples_R = 0;
target_delay_samples_L = 0;
target_delay_samples_R = 0;
attack_envelope = 1;

// Spring reverb delays - recalculate with new buffer size
spring_delay1 = min(floor(0.041 * srate), spring_buffer_size - 1);
spring_delay2 = min(floor(0.063 * srate), spring_buffer_size - 1);
spring_delay3 = min(floor(0.089 * srate), spring_buffer_size - 1);
spring_delay4 = min(floor(0.127 * srate), spring_buffer_size - 1);
spring_delay5 = min(floor(0.181 * srate), spring_buffer_size - 1);
spring_delay6 = min(floor(0.251 * srate), spring_buffer_size - 1);

// Modulation
mod_phase = 0;
tremolo_phase = 0;
phaser_phase = 0;

// Advanced modulation variables
lfo_sample_hold_value = 0;
lfo_sample_hold_timer = 0;
envelope_follower_state = 0;
envelope_attack = 0.01;
envelope_release = 0.1;

// Filter modulation tracking
last_low_cut = 0;
last_high_cut = 0;

// Filter states
lpf_L.x1 = lpf_L.x2 = lpf_L.y1 = lpf_L.y2 = 0;
lpf_R.x1 = lpf_R.x2 = lpf_R.y1 = lpf_R.y2 = 0;
hpf_L.x1 = hpf_L.x2 = hpf_L.y1 = hpf_L.y2 = 0;
hpf_R.x1 = hpf_R.x2 = hpf_R.y1 = hpf_R.y2 = 0;

// Filter states for spring reverb darkening
spring_lpf_L.x1 = spring_lpf_L.x2 = spring_lpf_L.y1 = spring_lpf_L.y2 = 0;
spring_lpf_R.x1 = spring_lpf_R.x2 = spring_lpf_R.y1 = spring_lpf_R.y2 = 0;
spring_lpf2_L.x1 = spring_lpf2_L.x2 = spring_lpf2_L.y1 = spring_lpf2_L.y2 = 0;
spring_lpf2_R.x1 = spring_lpf2_R.x2 = spring_lpf2_R.y1 = spring_lpf2_R.y2 = 0;

// Initialize modeling states
sample_hold_counter = 0;
sample_hold_L = 0;
sample_hold_R = 0;
tone_state_L = 0;
tone_state_R = 0;
tube_state_L = 0;
tube_state_R = 0;

// Smoothing
smooth_coeff = exp(-2 * $pi * 20 / srate);
smooth_factor = 1 - smooth_coeff;
smooth_threshold = 0.001;

// Optimization variables
inv_srate = 1.0 / srate;
ms_to_samples = srate * 0.001;
modulation_active = 0;
filter_modulation_active = 0;
lfo_increment = 0;
filter_update_needed = 0;

// Mouse variables and dropdown
mouse_knob = 0;
drag_start_y = 0;
last_mouse_cap = 0;
dropdown_open = 0;
dropdown_hover = -1;
delay_mode_dropdown_open = 0;
delay_mode_dropdown_hover = -1;

// New modulation dropdown variables
lfo_wave_dropdown_open = 0;
lfo_wave_dropdown_hover = -1;
lfo_target_dropdown_open = 0;
lfo_target_dropdown_hover = -1;
env_target_dropdown_open = 0;
env_target_dropdown_hover = -1;

// GFX optimization variables
current_font = -1;
current_scale = -1;

// Parameter smoothing function - optimized
function smooth_param_fast(current, target) (
  diff = target - current;
  abs(diff) < smooth_threshold ? target : (current + diff * smooth_factor);
);

// Optimized stereo safety limiter - less aggressive
function safety_limiter_stereo(input_L, input_R) (
  level_L = abs(input_L);
  level_R = abs(input_R);
  max_level = max(level_L, level_R);
  
  max_level > 0.95 ? (
    overage = (max_level - 0.95) * 20; // Less aggressive
    compression_ratio = 1 / (1 + overage);
    scale_factor = (0.95 + (max_level - 0.95) * compression_ratio) / max_level;
    this.left = input_L * scale_factor;
    this.right = input_R * scale_factor;
  ) : (
    this.left = input_L;
    this.right = input_R;
  );
);

// Simple delay read
function delay_read(buffer, delay_samples, write_pos) (
  min_delay_samples = floor(srate * 0.01); // Minimum 10ms in samples
  delay_samples = max(min_delay_samples, min(delay_samples, buffer_size - 1));
  read_pos = write_pos - delay_samples;
  read_pos < 0 ? read_pos += buffer_size;
  buffer[read_pos];
);

// Biquad filter functions
function bq_setlp(freq) (
  freq = max(20, min(freq, srate * 0.49));
  omega = 2 * $pi * freq / srate;
  cos_omega = cos(omega);
  sin_omega = sin(omega);
  alpha = sin_omega / (2 * 0.707);
  
  b0 = (1 - cos_omega) * 0.5;
  b1 = 1 - cos_omega;
  b2 = b0;
  a0 = 1 + alpha;
  a1 = -2 * cos_omega;
  a2 = 1 - alpha;
  
  this.b0 = b0 / a0;
  this.b1 = b1 / a0;
  this.b2 = b2 / a0;
  this.a1 = a1 / a0;
  this.a2 = a2 / a0;
);

function bq_sethp(freq) (
  freq = max(20, min(freq, srate * 0.49));
  omega = 2 * $pi * freq / srate;
  cos_omega = cos(omega);
  sin_omega = sin(omega);
  alpha = sin_omega / (2 * 0.707);
  
  b0 = (1 + cos_omega) * 0.5;
  b1 = -(1 + cos_omega);
  b2 = b0;
  a0 = 1 + alpha;
  a1 = -2 * cos_omega;
  a2 = 1 - alpha;
  
  this.b0 = b0 / a0;
  this.b1 = b1 / a0;
  this.b2 = b2 / a0;
  this.a1 = a1 / a0;
  this.a2 = a2 / a0;
);

function bq_process(input) (
  output = this.b0 * input + this.b1 * this.x1 + this.b2 * this.x2 
           - this.a1 * this.y1 - this.a2 * this.y2;
  
  this.x2 = this.x1; this.x1 = input;
  this.y2 = this.y1; this.y1 = output;
  output;
);

// Spring reverb - very long, very dark
function process_spring(input_L, input_R, amount) (
  amount > 0 ? (
    // Calculate read positions with proper bounds checking
    read1_L = (spring_write_L - spring_delay1 + spring_buffer_size) % spring_buffer_size;
    read1_R = (spring_write_R - spring_delay1 + spring_buffer_size) % spring_buffer_size;
    read2_L = (spring_write_L - spring_delay2 + spring_buffer_size) % spring_buffer_size;
    read2_R = (spring_write_R - spring_delay2 + spring_buffer_size) % spring_buffer_size;
    read3_L = (spring_write_L - spring_delay3 + spring_buffer_size) % spring_buffer_size;
    read3_R = (spring_write_R - spring_delay3 + spring_buffer_size) % spring_buffer_size;
    read4_L = (spring_write_L - spring_delay4 + spring_buffer_size) % spring_buffer_size;
    read4_R = (spring_write_R - spring_delay4 + spring_buffer_size) % spring_buffer_size;
    read5_L = (spring_write_L - spring_delay5 + spring_buffer_size) % spring_buffer_size;
    read5_R = (spring_write_R - spring_delay5 + spring_buffer_size) % spring_buffer_size;
    read6_L = (spring_write_L - spring_delay6 + spring_buffer_size) % spring_buffer_size;
    read6_R = (spring_write_R - spring_delay6 + spring_buffer_size) % spring_buffer_size;
    
    // Read taps
    tap1_L = spring_buffer_L[read1_L];
    tap1_R = spring_buffer_R[read1_R];
    tap2_L = spring_buffer_L[read2_L];
    tap2_R = spring_buffer_R[read2_R];
    tap3_L = spring_buffer_L[read3_L];
    tap3_R = spring_buffer_R[read3_R];
    tap4_L = spring_buffer_L[read4_L];
    tap4_R = spring_buffer_R[read4_R];
    tap5_L = spring_buffer_L[read5_L];
    tap5_R = spring_buffer_R[read5_R];
    tap6_L = spring_buffer_L[read6_L];
    tap6_R = spring_buffer_R[read6_R];
    
    // Early reflections
    early_L = tap1_L * 0.4 + tap2_R * 0.35 + tap3_L * 0.25;
    early_R = tap1_R * 0.4 + tap2_L * 0.35 + tap3_R * 0.25;
    
    // Apply first stage darkening
    early_L = spring_lpf_L.bq_process(early_L);
    early_R = spring_lpf_R.bq_process(early_R);
    
    // Late reflections
    late_L = tap4_L * 0.4 + tap5_R * 0.35 + tap6_L * 0.3;
    late_R = tap4_R * 0.4 + tap5_L * 0.35 + tap6_R * 0.3;
    
    // Aggressive darkening for late reflections
    late_L = spring_lpf_L.bq_process(late_L);
    late_R = spring_lpf_R.bq_process(late_R);
    late_L = spring_lpf2_L.bq_process(late_L);
    late_R = spring_lpf2_R.bq_process(late_R);
    
    late_L *= 0.4;
    late_R *= 0.4;
    
    // Combine early and late
    spring_L = early_L * 0.5 + late_L * 0.8;
    spring_R = early_R * 0.5 + late_R * 0.8;
    
    // Final darkening
    spring_L = spring_lpf_L.bq_process(spring_L);
    spring_R = spring_lpf_R.bq_process(spring_R);
    
    spring_L *= 0.5;
    spring_R *= 0.5;
    
    // Write with feedback
    feedback_gain = 0.82;
    spring_buffer_L[spring_write_L] = input_L + spring_L * feedback_gain;
    spring_buffer_R[spring_write_R] = input_R + spring_R * feedback_gain;
    
    // Update write positions
    spring_write_L = (spring_write_L + 1) % spring_buffer_size;
    spring_write_R = (spring_write_R + 1) % spring_buffer_size;
    
    this.left = spring_L * amount;
    this.right = spring_R * amount;
  ) : (
    this.left = 0;
    this.right = 0;
  );
);

// Tempo sync calculation
function calculate_sync_time(sync_index) local(beats, ms_per_beat) (
  ms_per_beat = 60000 / max(60, tempo);
  
  sync_index == 1 ? beats = 1/8 :
  sync_index == 2 ? beats = 1/6 :
  sync_index == 3 ? beats = 3/16 :
  sync_index == 4 ? beats = 1/4 :
  sync_index == 5 ? beats = 1/3 :
  sync_index == 6 ? beats = 3/8 :
  sync_index == 7 ? beats = 1/2 :
  sync_index == 8 ? beats = 2/3 :
  sync_index == 9 ? beats = 3/4 :
  sync_index == 10 ? beats = 1 :
  sync_index == 11 ? beats = 4/3 :
  sync_index == 12 ? beats = 1.5 :
  sync_index == 13 ? beats = 2 :
  sync_index == 14 ? beats = 8/3 :
  sync_index == 15 ? beats = 3 :
  sync_index == 16 ? beats = 4 :
  sync_index == 17 ? beats = 16/3 :
  sync_index == 18 ? beats = 6 :
  sync_index == 19 ? beats = 8 :
  sync_index == 20 ? beats = 32/3 :
  sync_index == 21 ? beats = 12 :
  sync_index == 22 ? beats = 16 :
  sync_index == 23 ? beats = 64/3 :
  sync_index == 24 ? beats = 24 :
  sync_index == 25 ? beats = 32 :
  sync_index == 26 ? beats = 128/3 :
  sync_index == 27 ? beats = 48 :
  sync_index == 28 ? beats = 64 :
  beats = 1;
  
  beats * ms_per_beat;
);

@slider

// Ensure L/R delay times have reasonable defaults
slider16 <= 10 ? slider16 = 400; // Default left to 400ms
slider17 <= 10 ? slider17 = 440; // Default right to 440ms

// Update delay time
(slider11 > 0) ? (
  sync_time = calculate_sync_time(slider11);
  slider10 = sync_time;
  // Also update left/right times for dual mode when synced
  slider16 = sync_time;
  slider17 = sync_time * 1.1; // Right slightly longer
);

target_delay_samples = floor(srate * max(10.0, slider10) * 0.001);
target_delay_samples = max(floor(srate * 0.01), min(target_delay_samples, buffer_size - 1)); // Ensure minimum 10ms

// For dual/stereo mode, calculate separate left/right delay times
target_delay_samples_L = floor(srate * max(10.0, slider16) * 0.001);
target_delay_samples_R = floor(srate * max(10.0, slider17) * 0.001);
target_delay_samples_L = max(floor(srate * 0.01), min(target_delay_samples_L, buffer_size - 1)); // Ensure minimum 10ms
target_delay_samples_R = max(floor(srate * 0.01), min(target_delay_samples_R, buffer_size - 1)); // Ensure minimum 10ms

// Pre-calculate modulation states for optimization
modulation_active = (slider42 > 0 && slider41 > 0 && slider40 > 0);
filter_modulation_active = (modulation_active && slider43 == 1) || (slider44 > 0 && slider45 > 0);
lfo_increment = modulation_active ? (slider40 * inv_srate) : 0;

// Update filters only when not being modulated
!filter_modulation_active ? (
  hpf_L.bq_sethp(slider20);  // Low Cut = High Pass
  hpf_R.bq_sethp(slider20);
  lpf_L.bq_setlp(slider21);  // High Cut = Low Pass  
  lpf_R.bq_setlp(slider21);
  last_low_cut = slider20;
  last_high_cut = slider21;
  filter_update_needed = 0;
) : (
  filter_update_needed = 1;
);

// Set up spring reverb darkening filters
spring_lpf_L.bq_setlp(3500);
spring_lpf_R.bq_setlp(3500);
spring_lpf2_L.bq_setlp(2000);
spring_lpf2_R.bq_setlp(2000);

@sample

// Smooth delay time changes - optimized
current_delay_samples = smooth_param_fast(current_delay_samples, target_delay_samples);
current_delay_samples = floor(current_delay_samples);

current_delay_samples_L = smooth_param_fast(current_delay_samples_L, target_delay_samples_L);
current_delay_samples_L = floor(current_delay_samples_L);

current_delay_samples_R = smooth_param_fast(current_delay_samples_R, target_delay_samples_R);
current_delay_samples_R = floor(current_delay_samples_R);

// Input processing
input_gain = 10^(slider1/20);
in_L = spl0 * input_gain;
in_R = spl1 * input_gain;

// Attack gate
slider4 > -89 ? (
  input_level = max(abs(in_L), abs(in_R));
  attack_thresh = 10^(slider4/20);
  input_level > attack_thresh ? (
    attack_envelope = smooth_param_fast(attack_envelope, 1);
  ) : (
    attack_envelope = smooth_param_fast(attack_envelope, 0);
  );
  gated_L = in_L * attack_envelope;
  gated_R = in_R * attack_envelope;
) : (
  gated_L = in_L;
  gated_R = in_R;
);

// Advanced Modulation - optimized with early exits
lfo_value = 0;
env_follower_value = 0;

// LFO Generation - only when active
modulation_active ? (
  mod_phase += lfo_increment;
  mod_phase >= 1 ? mod_phase -= 1;
  
  // Generate different waveforms
  slider42 == 1 ? ( // Sine
    lfo_value = sin(mod_phase * 6.283185307); // Pre-calculated 2*pi
  ) : slider42 == 2 ? ( // Triangle
    lfo_value = mod_phase < 0.5 ? (4 * mod_phase - 1) : (3 - 4 * mod_phase);
  ) : slider42 == 3 ? ( // Sawtooth
    lfo_value = 2 * mod_phase - 1;
  ) : slider42 == 4 ? ( // Square
    lfo_value = mod_phase < 0.5 ? -1 : 1;
  ) : slider42 == 5 ? ( // Sample & Hold
    lfo_sample_hold_timer += 1;
    lfo_sample_hold_timer >= (srate / max(0.1, slider40)) ? (
      lfo_sample_hold_timer = 0;
      lfo_sample_hold_value = (rand(2) - 1);
    );
    lfo_value = lfo_sample_hold_value;
  );
  
  // Scale by depth
  lfo_value *= slider41 * 0.01;
) : (
  // Reset LFO phase when disabled
  mod_phase = 0;
);

// Envelope Follower - only when enabled
slider44 > 0 ? (
  input_envelope = max(abs(in_L), abs(in_R));
  
  // Optimized envelope following
  input_envelope > envelope_follower_state ? (
    envelope_follower_state += (input_envelope - envelope_follower_state) * envelope_attack;
  ) : (
    envelope_follower_state += (input_envelope - envelope_follower_state) * envelope_release;
  );
  
  env_follower_value = envelope_follower_state * slider44 * 0.01;
) : (
  // Reset envelope follower when disabled
  env_follower_value = 0;
);

// Apply modulations to targets before delay processing
mod_delay_time = current_delay_samples;
mod_filter_cutoff = 1.0;
mod_feedback = slider12;

// LFO Modulation - only apply when LFO is actually active
modulation_active && lfo_value != 0 ? (
  slider43 == 0 ? ( // Delay Time
    mod_delay_time = current_delay_samples * (1 + lfo_value * 0.1);
  ) : slider43 == 1 ? ( // Filter Cutoff  
    mod_filter_cutoff = 1 + lfo_value * 0.5;
  ) : slider43 == 2 ? ( // Feedback
    mod_feedback = slider12 * (1 + lfo_value * 0.3);
  );
);

// Envelope Follower Modulation - only apply when envelope follower is active
slider44 > 0 && env_follower_value != 0 ? (
  slider45 == 1 ? ( // Low frequencies
    mod_filter_cutoff *= (1 - env_follower_value * 0.5);
  ) : slider45 == 2 ? ( // High frequencies  
    mod_filter_cutoff *= (1 + env_follower_value * 0.5);
  );
);

// Ensure modulated values stay in valid ranges
mod_delay_time = max(floor(srate * 0.01), min(buffer_size - 1, mod_delay_time));
mod_filter_cutoff = max(0.1, min(2.0, mod_filter_cutoff));
mod_feedback = max(0, min(1.5, mod_feedback));

// Delay processing with modulated parameters
delayed_L = 0;
delayed_R = 0;

// Use modulated delay time and feedback
actual_delay = mod_delay_time;
actual_feedback = mod_feedback;

// Ensure minimum delay time is respected
actual_delay = max(floor(srate * 0.01), actual_delay);

// For short delays, use higher feedback and normal processing
delay_time_ms = actual_delay / (srate * 0.001);
is_short_delay_range = (delay_time_ms < 100); // Under 100ms = short delay territory

is_short_delay_range ? (
  // Use normal feedback for short delays
  actual_feedback = min(slider12, 0.9);
) : (
  // Normal feedback limiting for longer delays
  actual_feedback = min(actual_feedback, 1.5);
);

slider13 == 0 ? ( // Single mode
  delayed_L = delay_read(delay_buffer_L, actual_delay, write_pos);
  delayed_R = delay_read(delay_buffer_R, actual_delay, write_pos);
  
  slider15 ? ( // Freeze mode - infinite loop
    delay_buffer_L[write_pos] = delayed_L;
    delay_buffer_R[write_pos] = delayed_R;
  ) : ( // Normal mode
    delay_buffer_L[write_pos] = gated_L + delayed_L * actual_feedback;
    delay_buffer_R[write_pos] = gated_R + delayed_R * actual_feedback;
  );
  
) : slider13 == 1 ? ( // Ping pong mode
  temp_L = delay_read(delay_buffer_L, actual_delay, write_pos);
  temp_R = delay_read(delay_buffer_R, actual_delay, write_pos);
  
  delayed_L = temp_L;
  delayed_R = temp_R;
  
  slider15 ? ( // Freeze mode
    delay_buffer_L[write_pos] = temp_R;
    delay_buffer_R[write_pos] = temp_L;
  ) : ( // Normal mode
    delay_buffer_L[write_pos] = gated_L + temp_R * actual_feedback;
    delay_buffer_R[write_pos] = gated_R + temp_L * actual_feedback;
  );
  
) : ( // Dual/Stereo mode - use separate left/right delay times
  actual_delay_L = max(floor(srate * 0.01), current_delay_samples_L);
  actual_delay_R = max(floor(srate * 0.01), current_delay_samples_R);
  
  delayed_L = delay_read(delay_buffer_L, actual_delay_L, write_pos);
  delayed_R = delay_read(delay_buffer_R, actual_delay_R, write_pos2);
  
  slider15 ? ( // Freeze mode
    delay_buffer_L[write_pos] = delayed_L;
    delay_buffer_R[write_pos2] = delayed_R;
  ) : ( // Normal mode
    delay_buffer_L[write_pos] = gated_L + delayed_L * actual_feedback;
    delay_buffer_R[write_pos2] = gated_R + delayed_R * actual_feedback;
    
    // Add cross feedback
    slider18 > 0 ? (
      delay_buffer_L[write_pos] += delayed_R * slider18;
      delay_buffer_R[write_pos2] += delayed_L * slider18;
    );
  );
);

// Update write positions
write_pos += 1;
write_pos >= buffer_size ? write_pos = 0;

// Always update write_pos2 in Dual/Stereo mode, and in Ping Pong mode for safety
(slider13 == 1 || slider13 == 2) ? (
  write_pos2 += 1;
  write_pos2 >= buffer_size ? write_pos2 = 0;
);

// Apply filtering only when needed and not in short delay range
filter_needs_processing = (slider20 > 20 || slider21 < 20000 || filter_modulation_active);

!is_short_delay_range && filter_needs_processing ? (
  filter_modulation_active ? (
    mod_low_cut = slider20 * mod_filter_cutoff;
    mod_high_cut = slider21 * mod_filter_cutoff;
    
    // Constrain to valid ranges
    mod_low_cut = max(20, min(20000, mod_low_cut));
    mod_high_cut = max(20, min(20000, mod_high_cut));
    
    // Update filter coefficients only when needed
    abs(mod_low_cut - last_low_cut) > 5 || abs(mod_high_cut - last_high_cut) > 5 ? (
      hpf_L.bq_sethp(mod_low_cut);
      hpf_R.bq_sethp(mod_low_cut);
      lpf_L.bq_setlp(mod_high_cut);
      lpf_R.bq_setlp(mod_high_cut);
      last_low_cut = mod_low_cut;
      last_high_cut = mod_high_cut;
    );
  );
  
  // Apply filtering to delayed signal
  delayed_L = lpf_L.bq_process(delayed_L);
  delayed_R = lpf_R.bq_process(delayed_R);
  delayed_L = hpf_L.bq_process(delayed_L);
  delayed_R = hpf_R.bq_process(delayed_R);
);

delayed_L = lpf_L.bq_process(delayed_L);
delayed_R = lpf_R.bq_process(delayed_R);
delayed_L = hpf_L.bq_process(delayed_L);
delayed_R = hpf_R.bq_process(delayed_R);

// Modeling - bypass in short delay range for cleaner signal
!is_short_delay_range && slider30 > 0 ? (
  slider30 == 1 ? ( // Hard Clip
    delayed_L > 0.8 ? delayed_L = 0.8 : delayed_L < -0.8 ? delayed_L = -0.8;
    delayed_R > 0.8 ? delayed_R = 0.8 : delayed_R < -0.8 ? delayed_R = -0.8;
    
  ) : slider30 == 2 ? ( // Soft Clip
    delayed_L = delayed_L / (1 + abs(delayed_L * 0.7));
    delayed_R = delayed_R / (1 + abs(delayed_R * 0.7));
    
  ) : slider30 == 3 ? ( // Tube - based on reference plugin
    // Map our drive slider (0-1) to gain range (1-2) like reference
    tube_gain = 1 + slider34;
    tone = slider35;
    
    // Apply gain
    x0 = delayed_L * tube_gain;
    x1 = delayed_R * tube_gain;
    
    // Tube saturation algorithm from reference (stereo mode)
    // Left channel
    x0 >= 1 ? y0 = 0.5;
    (x0 < 1 && x0 > 0) ? y0 = (-0.5 * x0^2) + x0;
    x0 <= -1 ? y0 = -0.5;
    (x0 < 0 && x0 > -1) ? y0 = (0.5 * x0^2) + x0;
    
    // Right channel  
    x1 >= 1 ? y1 = 0.5;
    (x1 < 1 && x1 > 0) ? y1 = (-0.5 * x1^2) + x1;
    x1 <= -1 ? y1 = -0.5;
    (x1 < 0 && x1 > -1) ? y1 = (0.5 * x1^2) + x1;
    
    // Gain compensation from reference
    comp_gain = tube_gain < 1 ? (1 / tube_gain) : tube_gain;
    
    // Apply compensation and output (output=1.0 as requested)
    delayed_L = y0 * comp_gain;
    delayed_R = y1 * comp_gain;
    
    // Tube tone control (kept from our original implementation)
    tone < 0.5 ? (
      cutoff = 1000 + tone * 8000;
      tube_smooth = exp(-2 * $pi * cutoff / srate);
      tube_state_L += (delayed_L - tube_state_L) * (1 - tube_smooth);
      tube_state_R += (delayed_R - tube_state_R) * (1 - tube_smooth);
      delayed_L = tube_state_L;
      delayed_R = tube_state_R;
    ) : (
      emphasis = (tone - 0.5) * 2;
      high_freq = delayed_L - tube_state_L;
      delayed_L = delayed_L + high_freq * emphasis * 0.3;
      high_freq = delayed_R - tube_state_R;
      delayed_R = delayed_R + high_freq * emphasis * 0.3;
      tube_state_L = delayed_L;
      tube_state_R = delayed_R;
    );
  );
);

// Spring reverb - keep separate from delay signal
spring_L = 0;
spring_R = 0;

slider5 > 0 ? (
  spring_amount = slider5 * 0.01;
  spring.process_spring(gated_L, gated_R, spring_amount);
  spring_L = spring.left;
  spring_R = spring.right;
);

// Don't add spring to delayed signal - keep them separate for clean delay

// Apply gentle safety limiting only to final output when needed
max_level = max(abs(delayed_L), abs(delayed_R));
max_level > 0.9 ? (
  scale_factor = 0.9 / max_level;
  delayed_L *= scale_factor;
  delayed_R *= scale_factor;
);

// Effects - bypass tremolo in short delay range for cleaner signal
!is_short_delay_range && slider51 > 0 ? (
  tremolo_phase += slider50 / srate;
  tremolo_phase >= 1 ? tremolo_phase -= 1;
  
  trem_lfo = sin(tremolo_phase * 2 * $pi);
  trem_gain = 1 - (slider51 * 0.01 * (1 - trem_lfo) * 0.5);
  delayed_L *= trem_gain;
  delayed_R *= trem_gain;
);

// Final mix and output - add spring reverb to final mix
dry_gain = 1 - slider3;
wet_gain = slider3;
output_gain = 10^(slider2/20);

// Mix dry and delayed signals first
mixed_L = spl0 * dry_gain + delayed_L * wet_gain;
mixed_R = spl1 * dry_gain + delayed_R * wet_gain;

// Add spring reverb to the final mixed signal
spl0 = (mixed_L + spring_L) * output_gain;
spl1 = (mixed_R + spring_R) * output_gain;

@gfx 900 600

// Simple anti-flashing: if slider30 is out of range, reset it
slider30 > 3 ? slider30 = 0;

// Calculate scale factor
base_width = 900;
base_height = 600;
scale_x = gfx_w / base_width;
scale_y = gfx_h / base_height;
scale = min(scale_x, scale_y);
scale = max(0.5, min(scale, 3.0));

// Pre-calculate commonly used scaled values for performance - recalculate when scale changes
current_scale != scale ? (
  s20 = floor(20 * scale);
  s30 = floor(30 * scale);
  s40 = floor(40 * scale);
  s50 = floor(50 * scale);
  s60 = floor(60 * scale);
  s70 = floor(70 * scale);
  s80 = floor(80 * scale);
  s100 = floor(100 * scale);
  s120 = floor(120 * scale);
  s140 = floor(140 * scale);
  s150 = floor(150 * scale);
  s170 = floor(170 * scale);
  s180 = floor(180 * scale);
  s200 = floor(200 * scale);
  s220 = floor(220 * scale);
  s240 = floor(240 * scale);
  s250 = floor(250 * scale);
  s260 = floor(260 * scale);
  s280 = floor(280 * scale);
  s290 = floor(290 * scale);
  s300 = floor(300 * scale);
  s320 = floor(320 * scale);
  s3 = floor(3 * scale);
  s4 = floor(4 * scale);
  s5 = floor(5 * scale);
  s10 = floor(10 * scale);
  s12 = floor(12 * scale);
  s15 = floor(15 * scale);
  s16 = floor(16 * scale);
  s18 = floor(18 * scale);
  knob_radius = s18;
  knob_click_radius_sq = (20 * scale)^2;
  
  // Set up fonts when scale changes
  gfx_setfont(1, "Arial", max(8, floor(18 * scale)), 'b');  // Title font
  gfx_setfont(2, "Arial", max(8, floor(12 * scale)));        // Subtitle font
  gfx_setfont(3, "Arial", max(8, floor(10 * scale)), 'b');   // Header font
  gfx_setfont(4, "Arial", max(6, floor(10 * scale)));        // Label font
  gfx_setfont(5, "Arial", max(8, floor(10 * scale)));        // UI text font
  current_font = -1; // Reset font cache
  
  current_scale = scale;
);

// Optimized font setting - only set when different
function set_font_cached(font_id) (
  current_font != font_id ? (
    gfx_setfont(font_id);
    current_font = font_id;
  );
);

// Optimized knob hit test
function knob_hit_test(knob_x, knob_y) (
  (mouse_x - knob_x)^2 + (mouse_y - knob_y)^2 < knob_click_radius_sq;
);

// Clear background once
gfx_r = 0.85; gfx_g = 0.85; gfx_b = 0.85;
gfx_rect(0, 0, gfx_w, gfx_h);

// Title panel
gfx_r = 0.72; gfx_g = 0.72; gfx_b = 0.72;
gfx_rect(s20, s10, gfx_w - s40, s50);

// Control panel
gfx_rect(s20, s80, gfx_w - s40, gfx_h - s120);

// Set up fonts - recalculate when scale changes
current_scale != scale ? (
  gfx_setfont(1, "Arial", max(8, floor(18 * scale)), 'b');  // Title font
  gfx_setfont(2, "Arial", max(8, floor(12 * scale)));        // Subtitle font
  gfx_setfont(3, "Arial", max(8, floor(10 * scale)), 'b');   // Header font
  gfx_setfont(4, "Arial", max(6, floor(10 * scale)));        // Label font
  gfx_setfont(5, "Arial", max(8, floor(10 * scale)));        // UI text font
);
current_font = -1; // Reset font cache

// Title text
gfx_r = 0; gfx_g = 0; gfx_b = 0;
set_font_cached(1);
gfx_x = s40; gfx_y = floor(22 * scale);
gfx_drawstr("Tycho Delay TMA-2");

set_font_cached(2);
gfx_x = s40; gfx_y = floor(42 * scale);
gfx_drawstr("Advanced Stereo Delay with Spring Reverb & Modulation");

// Red accent - longer and properly positioned within title panel
gfx_r = 0.55; gfx_g = 0; gfx_b = 0;
gfx_rect(gfx_w - s220, s20, s180, s4);

// Calculate centered column positions
available_width = gfx_w - s60;
column_width = available_width / 6;
start_x = s30;

col1_x = floor(start_x + column_width * 0.5);   // General
col2_x = floor(start_x + column_width * 1.5);   // Delay  
col3_x = floor(start_x + column_width * 2.5);   // Filters
col4_x = floor(start_x + column_width * 3.5);   // Modeling
col5_x = floor(start_x + column_width * 4.5);   // Modulation
col6_x = floor(start_x + column_width * 5.5);   // Effects

start_y = s140;

// Column headers
gfx_r = 0; gfx_g = 0; gfx_b = 0;
set_font_cached(3);

gfx_measurestr("GENERAL", label_w, label_h);
gfx_x = col1_x - label_w/2; gfx_y = s100; gfx_drawstr("GENERAL");

gfx_measurestr("DELAY", label_w, label_h);
gfx_x = col2_x - label_w/2; gfx_y = s100; gfx_drawstr("DELAY");

gfx_measurestr("FILTERS", label_w, label_h);
gfx_x = col3_x - label_w/2; gfx_y = s100; gfx_drawstr("FILTERS");

gfx_measurestr("MODELING", label_w, label_h);
gfx_x = col4_x - label_w/2; gfx_y = s100; gfx_drawstr("MODELING");

gfx_measurestr("MODULATION", label_w, label_h);
gfx_x = col5_x - label_w/2; gfx_y = s100; gfx_drawstr("MODULATION");

gfx_measurestr("EFFECTS", label_w, label_h);
gfx_x = col6_x - label_w/2; gfx_y = s100; gfx_drawstr("EFFECTS");

// Draw knob function with optional numeric readout
function draw_knob_with_readout(x, y, value, min_val, max_val, label, show_readout, units) local(norm_val, angle, ind_x, ind_y, readout_text) (
  norm_val = (value - min_val) / (max_val - min_val);
  norm_val = max(0, min(1, norm_val));
  angle = -2.356 + norm_val * 4.712;
  
  // Black knob circle
  gfx_r = 0.125; gfx_g = 0.125; gfx_b = 0.125;
  gfx_circle(x, y, knob_radius, 1);
  
  // White indicator line
  ind_x = x + sin(angle) * (knob_radius - s3);
  ind_y = y - cos(angle) * (knob_radius - s3);
  gfx_r = 1; gfx_g = 1; gfx_b = 1;
  gfx_line(x, y, ind_x, ind_y, max(1, floor(2 * scale)));
  
  // Label
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  set_font_cached(4);
  gfx_measurestr(label, label_w, label_h);
  gfx_x = x - label_w/2; gfx_y = y + knob_radius + s5;
  gfx_drawstr(label);
  
  // Numeric readout if requested
  show_readout ? (
    value < 1 ? (
      sprintf(readout_text, "%.1f%s", value, units);
    ) : value < 10 ? (
      sprintf(readout_text, "%.1f%s", value, units);
    ) : value < 100 ? (
      sprintf(readout_text, "%.0f%s", value, units);
    ) : (
      sprintf(readout_text, "%.0f%s", value, units);
    );
    
    gfx_r = 0.2; gfx_g = 0.2; gfx_b = 0.8; // Blue text for readouts
    set_font_cached(4);
    gfx_measurestr(readout_text, readout_w, readout_h);
    gfx_x = x - readout_w/2; gfx_y = y + knob_radius + s5 + label_h + s3;
    gfx_drawstr(readout_text);
  );
);

// Standard knob function (no readout)
function draw_knob(x, y, value, min_val, max_val, label) (
  draw_knob_with_readout(x, y, value, min_val, max_val, label, 0, "");
);

// Draw switch function
function draw_switch(x, y, state, label) local(switch_w, switch_h) (
  switch_w = s30;
  switch_h = s16;
  
  gfx_r = 0.125; gfx_g = 0.125; gfx_b = 0.125;
  gfx_rect(x - switch_w/2, y - switch_h/2, switch_w, switch_h);
  state ? (gfx_r = 0.55; gfx_g = 0; gfx_b = 0;) : (gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.25;);
  gfx_rect(x + (state ? floor(2 * scale) : floor(-13 * scale)), y - floor(6 * scale), floor(11 * scale), s12);
  
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  set_font_cached(4);
  gfx_measurestr(label, label_w, label_h);
  gfx_x = x - label_w/2; gfx_y = y + s15;
  gfx_drawstr(label);
);

// Draw dropdown function with label
function draw_dropdown(x, y, width, height, current_text, label) local(arrow_x, arrow_y) (
  // Label above dropdown
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  set_font_cached(4);
  gfx_measurestr(label, label_w, label_h);
  gfx_x = x + width/2 - label_w/2; 
  gfx_y = y - label_h - s5;
  gfx_drawstr(label);
  
  // Background
  gfx_r = 0.2; gfx_g = 0.2; gfx_b = 0.2;
  gfx_rect(x, y, width, height);
  
  // Current selection text
  gfx_r = 1; gfx_g = 1; gfx_b = 1;
  set_font_cached(5);
  gfx_measurestr(current_text, text_w, text_h);
  gfx_x = x + s3;
  gfx_y = y + (height - text_h)/2;
  gfx_drawstr(current_text);
  
  // Dropdown arrow
  arrow_x = x + width - s12;
  arrow_y = y + height/2;
  gfx_r = 0.8; gfx_g = 0.8; gfx_b = 0.8;
  gfx_line(arrow_x, arrow_y - s3, arrow_x + s4, arrow_y + s3, 1);
  gfx_line(arrow_x + floor(8 * scale), arrow_y - s3, arrow_x + s4, arrow_y + s3, 1);
);

// Draw all knobs with optimized positions
draw_knob(col1_x, start_y, slider1, -90, 15, "INPUT");
draw_knob(col1_x, start_y + s70, slider2, -90, 15, "OUTPUT");
draw_knob(col1_x, start_y + s140, slider3 * 100, 0, 100, "MIX");
draw_knob(col1_x, start_y + floor(210 * scale), slider4, -90, 0, "ATTACK");
draw_knob(col1_x, start_y + s280, slider5, 0, 100, "SPRING");

// Delay Mode dropdown - below DELAY heading
delay_mode_dropdown_width = s80;
delay_mode_dropdown_height = s16;
delay_mode_dropdown_x = col2_x - delay_mode_dropdown_width/2;
delay_mode_dropdown_y = start_y;

delay_mode_text = "";
slider13 == 0 ? delay_mode_text = "Single";
slider13 == 1 ? delay_mode_text = "Ping Pong";
slider13 == 2 ? delay_mode_text = "Dual/Stereo";

draw_dropdown(delay_mode_dropdown_x, delay_mode_dropdown_y, delay_mode_dropdown_width, delay_mode_dropdown_height, delay_mode_text, "MODE");

// Show different controls based on delay mode
slider13 == 2 ? ( // Dual/Stereo mode - show separate L/R controls
  draw_knob_with_readout(col2_x - s30, start_y + s80, slider16, 10, 6000, "LEFT", 1, "ms");
  draw_knob_with_readout(col2_x + s30, start_y + s80, slider17, 10, 6000, "RIGHT", 1, "ms");
  draw_knob(col2_x - s30, start_y + s180, slider12 * 100, 0, 150, "FEEDBACK");
  draw_knob(col2_x + s30, start_y + s180, slider18 * 100, 0, 150, "CROSS FB");
  draw_switch(col2_x, start_y + s250, slider11 > 0, "SYNC");
  draw_switch(col2_x, start_y + s290, slider15, "FREEZE");
) : ( // Single or Ping Pong mode - show single controls
  draw_knob_with_readout(col2_x, start_y + s80, slider10, 10, 6000, "TIME", 1, "ms");
  draw_knob(col2_x, start_y + s180, slider12 * 100, 0, 150, "FEEDBACK");
  draw_switch(col2_x, start_y + s250, slider11 > 0, "SYNC");
  draw_switch(col2_x, start_y + s290, slider15, "FREEZE");
);

draw_knob(col3_x, start_y, slider20, 20, 20000, "LOW CUT");
draw_knob(col3_x, start_y + s70, slider21, 20, 20000, "HIGH CUT");

draw_knob(col5_x, start_y, slider40, 0, 10, "LFO RATE");
draw_knob(col5_x, start_y + s60, slider41, 0, 100, "LFO DEPTH");

// LFO Wave dropdown with label
lfo_wave_dropdown_y = start_y + s120;
lfo_wave_dropdown_w = s80;
lfo_wave_dropdown_h = s16;
lfo_wave_dropdown_x = col5_x - lfo_wave_dropdown_w/2;

wave_text = "";
slider42 == 0 ? wave_text = "Off";
slider42 == 1 ? wave_text = "Sine";
slider42 == 2 ? wave_text = "Triangle";
slider42 == 3 ? wave_text = "Sawtooth";
slider42 == 4 ? wave_text = "Square";
slider42 == 5 ? wave_text = "S&H";

draw_dropdown(lfo_wave_dropdown_x, lfo_wave_dropdown_y, lfo_wave_dropdown_w, lfo_wave_dropdown_h, wave_text, "LFO WAVE");

// LFO Target dropdown with label
lfo_target_dropdown_y = start_y + s170;
lfo_target_dropdown_w = s80;
lfo_target_dropdown_h = s16;
lfo_target_dropdown_x = col5_x - lfo_target_dropdown_w/2;

target_text = "";
slider43 == 0 ? target_text = "Delay Time";
slider43 == 1 ? target_text = "Filter Cut";
slider43 == 2 ? target_text = "Feedback";

draw_dropdown(lfo_target_dropdown_x, lfo_target_dropdown_y, lfo_target_dropdown_w, lfo_target_dropdown_h, target_text, "LFO TARGET");

draw_knob(col5_x, start_y + s240, slider44, 0, 100, "ENV FOLLOW");

// Env Target dropdown with label
env_target_dropdown_y = start_y + s320;
env_target_dropdown_w = s80;
env_target_dropdown_h = s16;
env_target_dropdown_x = col5_x - env_target_dropdown_w/2;

env_text = "";
slider45 == 0 ? env_text = "Off";
slider45 == 1 ? env_text = "Low Freq";
slider45 == 2 ? env_text = "High Freq";

draw_dropdown(env_target_dropdown_x, env_target_dropdown_y, env_target_dropdown_w, env_target_dropdown_h, env_text, "ENV TARGET");

draw_knob(col6_x, start_y, slider50, 0, 10, "TREM RATE");
draw_knob(col6_x, start_y + s70, slider51, 0, 100, "TREM DEPTH");

// Column 4: Modeling dropdown
dropdown_width = s100;
dropdown_height = s20;
dropdown_x = col4_x - dropdown_width/2;
dropdown_y = start_y;

modeling_text = "";
slider30 == 0 ? modeling_text = "No Modeling";
slider30 == 1 ? modeling_text = "Hard Clip";
slider30 == 2 ? modeling_text = "Soft Clip";
slider30 == 3 ? modeling_text = "Tube";

draw_dropdown(dropdown_x, dropdown_y, dropdown_width, dropdown_height, modeling_text, "TYPE");

// Show modeling knobs based on selection
slider30 == 3 ? ( // Tube controls
  draw_knob(col4_x, start_y + s50, slider34 * 100, 0, 100, "DRIVE");
  draw_knob(col4_x, start_y + s120, slider35 * 100, 0, 100, "TONE");
);

// Mouse interaction - fixed dropdown handling
mouse_cap & 1 && !(last_mouse_cap & 1) ? (
  // Check dropdown interactions first
  clicked_dropdown = 0;
  
  // Close all dropdowns first
  close_all_dropdowns = 1;
  
  // Delay mode dropdown interaction
  mouse_x >= delay_mode_dropdown_x && mouse_x <= delay_mode_dropdown_x + delay_mode_dropdown_width &&
  mouse_y >= delay_mode_dropdown_y && mouse_y <= delay_mode_dropdown_y + delay_mode_dropdown_height ? (
    delay_mode_dropdown_open = !delay_mode_dropdown_open;
    close_all_dropdowns = 0;
    clicked_dropdown = 1;
  ) : delay_mode_dropdown_open && mouse_x >= delay_mode_dropdown_x && mouse_x <= delay_mode_dropdown_x + delay_mode_dropdown_width &&
  mouse_y >= delay_mode_dropdown_y + delay_mode_dropdown_height && mouse_y <= delay_mode_dropdown_y + delay_mode_dropdown_height + 3 * delay_mode_dropdown_height ? (
    option_index = floor((mouse_y - delay_mode_dropdown_y - delay_mode_dropdown_height) / delay_mode_dropdown_height);
    option_index >= 0 && option_index < 3 ? (
      slider13 = option_index;
      sliderchange(13);
      delay_mode_dropdown_open = 0;
    );
    clicked_dropdown = 1;
    close_all_dropdowns = 0;
  
  // Modeling dropdown interaction
  ) : mouse_x >= dropdown_x && mouse_x <= dropdown_x + dropdown_width &&
  mouse_y >= dropdown_y && mouse_y <= dropdown_y + dropdown_height ? (
    dropdown_open = !dropdown_open;
    close_all_dropdowns = 0;
    clicked_dropdown = 1;
  ) : dropdown_open && mouse_x >= dropdown_x && mouse_x <= dropdown_x + dropdown_width &&
  mouse_y >= dropdown_y + dropdown_height && mouse_y <= dropdown_y + dropdown_height + 4 * dropdown_height ? (
    option_index = floor((mouse_y - dropdown_y - dropdown_height) / dropdown_height);
    option_index >= 0 && option_index < 4 ? (
      slider30 = option_index;
      sliderchange(30);
      dropdown_open = 0;
    );
    clicked_dropdown = 1;
    close_all_dropdowns = 0;
  
  // LFO Wave dropdown interaction
  ) : mouse_x >= lfo_wave_dropdown_x && mouse_x <= lfo_wave_dropdown_x + lfo_wave_dropdown_w &&
  mouse_y >= lfo_wave_dropdown_y && mouse_y <= lfo_wave_dropdown_y + lfo_wave_dropdown_h ? (
    lfo_wave_dropdown_open = !lfo_wave_dropdown_open;
    close_all_dropdowns = 0;
    clicked_dropdown = 1;
  ) : lfo_wave_dropdown_open && mouse_x >= lfo_wave_dropdown_x && mouse_x <= lfo_wave_dropdown_x + lfo_wave_dropdown_w &&
  mouse_y >= lfo_wave_dropdown_y + lfo_wave_dropdown_h && mouse_y <= lfo_wave_dropdown_y + lfo_wave_dropdown_h + 6 * lfo_wave_dropdown_h ? (
    option_index = floor((mouse_y - lfo_wave_dropdown_y - lfo_wave_dropdown_h) / lfo_wave_dropdown_h);
    option_index >= 0 && option_index < 6 ? (
      slider42 = option_index;
      sliderchange(42);
      lfo_wave_dropdown_open = 0;
    );
    clicked_dropdown = 1;
    close_all_dropdowns = 0;
  
  // LFO Target dropdown interaction
  ) : mouse_x >= lfo_target_dropdown_x && mouse_x <= lfo_target_dropdown_x + lfo_target_dropdown_w &&
  mouse_y >= lfo_target_dropdown_y && mouse_y <= lfo_target_dropdown_y + lfo_target_dropdown_h ? (
    lfo_target_dropdown_open = !lfo_target_dropdown_open;
    close_all_dropdowns = 0;
    clicked_dropdown = 1;
  ) : lfo_target_dropdown_open && mouse_x >= lfo_target_dropdown_x && mouse_x <= lfo_target_dropdown_x + lfo_target_dropdown_w &&
  mouse_y >= lfo_target_dropdown_y + lfo_target_dropdown_h && mouse_y <= lfo_target_dropdown_y + lfo_target_dropdown_h + 3 * lfo_target_dropdown_h ? (
    option_index = floor((mouse_y - lfo_target_dropdown_y - lfo_target_dropdown_h) / lfo_target_dropdown_h);
    option_index >= 0 && option_index < 3 ? (
      slider43 = option_index;
      sliderchange(43);
      lfo_target_dropdown_open = 0;
    );
    clicked_dropdown = 1;
    close_all_dropdowns = 0;
  
  // Env Target dropdown interaction
  ) : mouse_x >= env_target_dropdown_x && mouse_x <= env_target_dropdown_x + env_target_dropdown_w &&
  mouse_y >= env_target_dropdown_y && mouse_y <= env_target_dropdown_y + env_target_dropdown_h ? (
    env_target_dropdown_open = !env_target_dropdown_open;
    close_all_dropdowns = 0;
    clicked_dropdown = 1;
  ) : env_target_dropdown_open && mouse_x >= env_target_dropdown_x && mouse_x <= env_target_dropdown_x + env_target_dropdown_w &&
  mouse_y >= env_target_dropdown_y + env_target_dropdown_h && mouse_y <= env_target_dropdown_y + env_target_dropdown_h + 3 * env_target_dropdown_h ? (
    option_index = floor((mouse_y - env_target_dropdown_y - env_target_dropdown_h) / env_target_dropdown_h);
    option_index >= 0 && option_index < 3 ? (
      slider45 = option_index;
      sliderchange(45);
      env_target_dropdown_open = 0;
    );
    clicked_dropdown = 1;
    close_all_dropdowns = 0;
  );
  
  // Close all dropdowns if clicked elsewhere
  close_all_dropdowns ? (
    dropdown_open = 0;
    delay_mode_dropdown_open = 0;
    lfo_wave_dropdown_open = 0;
    lfo_target_dropdown_open = 0;
    env_target_dropdown_open = 0;
  );

  // Optimized knob clicks using hit test function
  !clicked_dropdown ? (
    knob_hit_test(col1_x, start_y) ? (mouse_knob = 1; drag_start_y = mouse_y;);
    knob_hit_test(col1_x, start_y + s70) ? (mouse_knob = 2; drag_start_y = mouse_y;);
    knob_hit_test(col1_x, start_y + s140) ? (mouse_knob = 3; drag_start_y = mouse_y;);
    knob_hit_test(col1_x, start_y + floor(210 * scale)) ? (mouse_knob = 4; drag_start_y = mouse_y;);
    knob_hit_test(col1_x, start_y + s280) ? (mouse_knob = 5; drag_start_y = mouse_y;);
    
    // Delay knobs - different based on mode
    slider13 == 2 ? ( // Dual/Stereo mode
      knob_hit_test(col2_x - s30, start_y + s80) ? (mouse_knob = 16; drag_start_y = mouse_y;);
      knob_hit_test(col2_x + s30, start_y + s80) ? (mouse_knob = 17; drag_start_y = mouse_y;);
      knob_hit_test(col2_x - s30, start_y + s180) ? (mouse_knob = 12; drag_start_y = mouse_y;);
      knob_hit_test(col2_x + s30, start_y + s180) ? (mouse_knob = 18; drag_start_y = mouse_y;);
    ) : ( // Single or Ping Pong mode
      knob_hit_test(col2_x, start_y + s80) ? (mouse_knob = 10; drag_start_y = mouse_y;);
      knob_hit_test(col2_x, start_y + s180) ? (mouse_knob = 12; drag_start_y = mouse_y;);
    );
    
    knob_hit_test(col3_x, start_y) ? (mouse_knob = 20; drag_start_y = mouse_y;);
    knob_hit_test(col3_x, start_y + s70) ? (mouse_knob = 21; drag_start_y = mouse_y;);
    
    // Modeling knobs
    slider30 == 3 ? (
      knob_hit_test(col4_x, start_y + s50) ? (mouse_knob = 34; drag_start_y = mouse_y;);
      knob_hit_test(col4_x, start_y + s120) ? (mouse_knob = 35; drag_start_y = mouse_y;);
    );
    
    // Modulation knobs
    knob_hit_test(col5_x, start_y) ? (mouse_knob = 40; drag_start_y = mouse_y;);
    knob_hit_test(col5_x, start_y + s60) ? (mouse_knob = 41; drag_start_y = mouse_y;);
    knob_hit_test(col5_x, start_y + s240) ? (mouse_knob = 44; drag_start_y = mouse_y;);
    
    knob_hit_test(col6_x, start_y) ? (mouse_knob = 50; drag_start_y = mouse_y;);
    knob_hit_test(col6_x, start_y + s70) ? (mouse_knob = 51; drag_start_y = mouse_y;);

    // Delay switches - optimized with pre-calculated values
    slider13 == 2 ? ( // Dual/Stereo mode
      abs(mouse_x - col2_x) < s20 && abs(mouse_y - (start_y + s250)) < s10 ? (
        slider11 = slider11 > 0 ? 0 : 10; sliderchange(11);
      );
      abs(mouse_x - col2_x) < s20 && abs(mouse_y - (start_y + s290)) < s10 ? (
        slider15 = !slider15; sliderchange(15);
      );
    ) : ( // Single or Ping Pong mode
      abs(mouse_x - col2_x) < s20 && abs(mouse_y - (start_y + s250)) < s10 ? (
        slider11 = slider11 > 0 ? 0 : 10; sliderchange(11);
      );
      abs(mouse_x - col2_x) < s20 && abs(mouse_y - (start_y + s290)) < s10 ? (
        slider15 = !slider15; sliderchange(15);
      );
    );
  );
);

// Track dropdown hover states
dropdown_open ? (
  mouse_x >= dropdown_x && mouse_x <= dropdown_x + dropdown_width &&
  mouse_y >= dropdown_y + dropdown_height && mouse_y <= dropdown_y + dropdown_height + 4 * dropdown_height ? (
    dropdown_hover = floor((mouse_y - dropdown_y - dropdown_height) / dropdown_height);
  ) : (
    dropdown_hover = -1;
  );
);

delay_mode_dropdown_open ? (
  mouse_x >= delay_mode_dropdown_x && mouse_x <= delay_mode_dropdown_x + delay_mode_dropdown_width &&
  mouse_y >= delay_mode_dropdown_y + delay_mode_dropdown_height && mouse_y <= delay_mode_dropdown_y + delay_mode_dropdown_height + 3 * delay_mode_dropdown_height ? (
    delay_mode_dropdown_hover = floor((mouse_y - delay_mode_dropdown_y - delay_mode_dropdown_height) / delay_mode_dropdown_height);
  ) : (
    delay_mode_dropdown_hover = -1;
  );
);

lfo_wave_dropdown_open ? (
  mouse_x >= lfo_wave_dropdown_x && mouse_x <= lfo_wave_dropdown_x + lfo_wave_dropdown_w &&
  mouse_y >= lfo_wave_dropdown_y + lfo_wave_dropdown_h && mouse_y <= lfo_wave_dropdown_y + lfo_wave_dropdown_h + 6 * lfo_wave_dropdown_h ? (
    lfo_wave_dropdown_hover = floor((mouse_y - lfo_wave_dropdown_y - lfo_wave_dropdown_h) / lfo_wave_dropdown_h);
  ) : (
    lfo_wave_dropdown_hover = -1;
  );
);

lfo_target_dropdown_open ? (
  mouse_x >= lfo_target_dropdown_x && mouse_x <= lfo_target_dropdown_x + lfo_target_dropdown_w &&
  mouse_y >= lfo_target_dropdown_y + lfo_target_dropdown_h && mouse_y <= lfo_target_dropdown_y + lfo_target_dropdown_h + 3 * lfo_target_dropdown_h ? (
    lfo_target_dropdown_hover = floor((mouse_y - lfo_target_dropdown_y - lfo_target_dropdown_h) / lfo_target_dropdown_h);
  ) : (
    lfo_target_dropdown_hover = -1;
  );
);

env_target_dropdown_open ? (
  mouse_x >= env_target_dropdown_x && mouse_x <= env_target_dropdown_x + env_target_dropdown_w &&
  mouse_y >= env_target_dropdown_y + env_target_dropdown_h && mouse_y <= env_target_dropdown_y + env_target_dropdown_h + 3 * env_target_dropdown_h ? (
    env_target_dropdown_hover = floor((mouse_y - env_target_dropdown_y - env_target_dropdown_h) / env_target_dropdown_h);
  ) : (
    env_target_dropdown_hover = -1;
  );
);

// Knob dragging
mouse_cap & 1 && mouse_knob > 0 ? (
  mouse_dy = mouse_y - drag_start_y;
  drag_start_y = mouse_y;
  
  mouse_knob == 1 ? (slider1 = max(-90, min(15, slider1 - mouse_dy * 0.5)); sliderchange(1););
  mouse_knob == 2 ? (slider2 = max(-90, min(15, slider2 - mouse_dy * 0.5)); sliderchange(2););
  mouse_knob == 3 ? (slider3 = max(0, min(1, slider3 - mouse_dy * 0.005)); sliderchange(3););
  mouse_knob == 4 ? (slider4 = max(-90, min(0, slider4 - mouse_dy * 0.5)); sliderchange(4););
  mouse_knob == 5 ? (slider5 = max(0, min(100, slider5 - mouse_dy * 0.5)); sliderchange(5););
  
  mouse_knob == 10 ? (slider10 = max(10, min(6000, slider10 - mouse_dy * 10)); sliderchange(10););
  mouse_knob == 12 ? (slider12 = max(0, min(1.5, slider12 - mouse_dy * 0.005)); sliderchange(12););
  mouse_knob == 16 ? (slider16 = max(10, min(6000, slider16 - mouse_dy * 10)); sliderchange(16););
  mouse_knob == 17 ? (slider17 = max(10, min(6000, slider17 - mouse_dy * 10)); sliderchange(17););
  mouse_knob == 18 ? (slider18 = max(0, min(1.5, slider18 - mouse_dy * 0.005)); sliderchange(18););
  
  mouse_knob == 20 ? (slider20 = max(20, min(20000, slider20 - mouse_dy * 100)); sliderchange(20););
  mouse_knob == 21 ? (slider21 = max(20, min(20000, slider21 - mouse_dy * 100)); sliderchange(21););
  
  mouse_knob == 31 ? (slider31 = max(1, min(16, slider31 - mouse_dy * 0.1)); sliderchange(31););
  mouse_knob == 32 ? (slider32 = max(0.1, min(1, slider32 - mouse_dy * 0.005)); sliderchange(32););
  mouse_knob == 33 ? (slider33 = max(0, min(1, slider33 - mouse_dy * 0.005)); sliderchange(33););
  mouse_knob == 34 ? (slider34 = max(0, min(1, slider34 - mouse_dy * 0.005)); sliderchange(34););
  mouse_knob == 35 ? (slider35 = max(0, min(1, slider35 - mouse_dy * 0.005)); sliderchange(35););
  
  mouse_knob == 40 ? (slider40 = max(0, min(10, slider40 - mouse_dy * 0.05)); sliderchange(40););
  mouse_knob == 41 ? (slider41 = max(0, min(100, slider41 - mouse_dy * 0.5)); sliderchange(41););
  mouse_knob == 44 ? (slider44 = max(0, min(100, slider44 - mouse_dy * 0.5)); sliderchange(44););
  
  mouse_knob == 50 ? (slider50 = max(0, min(10, slider50 - mouse_dy * 0.05)); sliderchange(50););
  mouse_knob == 51 ? (slider51 = max(0, min(100, slider51 - mouse_dy * 0.5)); sliderchange(51););
) : (
  mouse_knob = 0;
);

last_mouse_cap = mouse_cap;

// Draw dropdown lists LAST so they appear on top of everything
dropdown_open ? (
  list_height = 4 * dropdown_height;
  gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.15;
  gfx_rect(dropdown_x, dropdown_y + dropdown_height, dropdown_width, list_height);
  
  set_font_cached(5);
  i = 0;
  loop(4,
    option_y = dropdown_y + dropdown_height + i * dropdown_height;
    
    // Highlight hovered option
    dropdown_hover == i ? (
      gfx_r = 0.55; gfx_g = 0; gfx_b = 0;
      gfx_rect(dropdown_x, option_y, dropdown_width, dropdown_height);
    );
    
    // Option text
    i == slider30 ? (gfx_r = 0.9; gfx_g = 0.7; gfx_b = 0.1;) : (gfx_r = 0.9; gfx_g = 0.9; gfx_b = 0.9;);
    gfx_x = dropdown_x + s5;
    gfx_y = option_y + (dropdown_height - text_h)/2;
    
    i == 0 ? gfx_drawstr("No Modeling");
    i == 1 ? gfx_drawstr("Hard Clip");
    i == 2 ? gfx_drawstr("Soft Clip");
    i == 3 ? gfx_drawstr("Tube");
    
    i += 1;
  );
);

// Draw delay mode dropdown list
delay_mode_dropdown_open ? (
  list_height = 3 * delay_mode_dropdown_height;
  gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.15;
  gfx_rect(delay_mode_dropdown_x, delay_mode_dropdown_y + delay_mode_dropdown_height, delay_mode_dropdown_width, list_height);
  
  set_font_cached(5);
  i = 0;
  loop(3,
    option_y = delay_mode_dropdown_y + delay_mode_dropdown_height + i * delay_mode_dropdown_height;
    
    // Highlight hovered option
    delay_mode_dropdown_hover == i ? (
      gfx_r = 0.55; gfx_g = 0; gfx_b = 0;
      gfx_rect(delay_mode_dropdown_x, option_y, delay_mode_dropdown_width, delay_mode_dropdown_height);
    );
    
    // Option text
    i == slider13 ? (gfx_r = 0.9; gfx_g = 0.7; gfx_b = 0.1;) : (gfx_r = 0.9; gfx_g = 0.9; gfx_b = 0.9;);
    gfx_x = delay_mode_dropdown_x + s3;
    gfx_y = option_y + (delay_mode_dropdown_height - text_h)/2;
    
    i == 0 ? gfx_drawstr("Single");
    i == 1 ? gfx_drawstr("Ping Pong");
    i == 2 ? gfx_drawstr("Dual/Stereo");
    
    i += 1;
  );
);

// Draw LFO Wave dropdown list
lfo_wave_dropdown_open ? (
  list_height = 6 * lfo_wave_dropdown_h;
  gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.15;
  gfx_rect(lfo_wave_dropdown_x, lfo_wave_dropdown_y + lfo_wave_dropdown_h, lfo_wave_dropdown_w, list_height);
  
  set_font_cached(5);
  i = 0;
  loop(6,
    option_y = lfo_wave_dropdown_y + lfo_wave_dropdown_h + i * lfo_wave_dropdown_h;
    
    // Highlight hovered option
    lfo_wave_dropdown_hover == i ? (
      gfx_r = 0.55; gfx_g = 0; gfx_b = 0;
      gfx_rect(lfo_wave_dropdown_x, option_y, lfo_wave_dropdown_w, lfo_wave_dropdown_h);
    );
    
    // Option text
    i == slider42 ? (gfx_r = 0.9; gfx_g = 0.7; gfx_b = 0.1;) : (gfx_r = 0.9; gfx_g = 0.9; gfx_b = 0.9;);
    gfx_x = lfo_wave_dropdown_x + s3;
    gfx_y = option_y + (lfo_wave_dropdown_h - text_h)/2;
    
    i == 0 ? gfx_drawstr("Off");
    i == 1 ? gfx_drawstr("Sine");
    i == 2 ? gfx_drawstr("Triangle");
    i == 3 ? gfx_drawstr("Sawtooth");
    i == 4 ? gfx_drawstr("Square");
    i == 5 ? gfx_drawstr("S&H");
    
    i += 1;
  );
);

// Draw LFO Target dropdown list
lfo_target_dropdown_open ? (
  list_height = 3 * lfo_target_dropdown_h;
  gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.15;
  gfx_rect(lfo_target_dropdown_x, lfo_target_dropdown_y + lfo_target_dropdown_h, lfo_target_dropdown_w, list_height);
  
  set_font_cached(5);
  i = 0;
  loop(3,
    option_y = lfo_target_dropdown_y + lfo_target_dropdown_h + i * lfo_target_dropdown_h;
    
    // Highlight hovered option
    lfo_target_dropdown_hover == i ? (
      gfx_r = 0.55; gfx_g = 0; gfx_b = 0;
      gfx_rect(lfo_target_dropdown_x, option_y, lfo_target_dropdown_w, lfo_target_dropdown_h);
    );
    
    // Option text
    i == slider43 ? (gfx_r = 0.9; gfx_g = 0.7; gfx_b = 0.1;) : (gfx_r = 0.9; gfx_g = 0.9; gfx_b = 0.9;);
    gfx_x = lfo_target_dropdown_x + s3;
    gfx_y = option_y + (lfo_target_dropdown_h - text_h)/2;
    
    i == 0 ? gfx_drawstr("Delay Time");
    i == 1 ? gfx_drawstr("Filter Cut");
    i == 2 ? gfx_drawstr("Feedback");
    
    i += 1;
  );
);

// Draw Env Target dropdown list
env_target_dropdown_open ? (
  list_height = 3 * env_target_dropdown_h;
  gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.15;
  gfx_rect(env_target_dropdown_x, env_target_dropdown_y + env_target_dropdown_h, env_target_dropdown_w, list_height);
  
  set_font_cached(5);
  i = 0;
  loop(3,
    option_y = env_target_dropdown_y + env_target_dropdown_h + i * env_target_dropdown_h;
    
    // Highlight hovered option
    env_target_dropdown_hover == i ? (
      gfx_r = 0.55; gfx_g = 0; gfx_b = 0;
      gfx_rect(env_target_dropdown_x, option_y, env_target_dropdown_w, env_target_dropdown_h);
    );
    
    // Option text
    i == slider45 ? (gfx_r = 0.9; gfx_g = 0.7; gfx_b = 0.1;) : (gfx_r = 0.9; gfx_g = 0.9; gfx_b = 0.9;);
    gfx_x = env_target_dropdown_x + s3;
    gfx_y = option_y + (env_target_dropdown_h - text_h)/2;
    
    i == 0 ? gfx_drawstr("Off");
    i == 1 ? gfx_drawstr("Low Freq");
    i == 2 ? gfx_drawstr("High Freq");
    
    i += 1;
  );
);